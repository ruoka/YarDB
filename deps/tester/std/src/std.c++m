module;
#include <version>
// C++ STD
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <strstream>
#include <typeinfo>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <valarray>
#include <vector>
// C++11
#include <array>
#include <atomic>
#include <chrono>
#include <codecvt>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <type_traits>
#include <typeindex>
// C++17
#include <any>
#include <execution>
#include <filesystem>
#ifdef __cpp_lib_memory_resource
#include <memory_resource>
#endif
#include <optional>
#include <shared_mutex>
#include <string_view>
#include <variant>
// C++20
#include <barrier>
#include <bit>
#include <charconv>
#include <compare>
#include <concepts>
#include <coroutine>
#include <format>
#include <latch>
#include <numbers>
#include <ranges>
#include <semaphore>
#ifdef __cpp_lib_source_location
#include <source_location>
#endif
#include <span>
#ifdef __cpp_lib_jthread
#include <stop_token>
#endif
#ifdef __cpp_lib_syncbuf
#include <syncstream>
#endif

// C++23
#ifdef __cpp_lib_flat_map
#include <flat_map>
#endif

// C++ headers for C
#include <cassert>
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <climits>
#include <clocale>
#define __STDCPP_WANT_MATH_SPEC_FUNCS__
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cwchar>
#include <cwctype>
// C++11
#include <cfenv>
#include <cinttypes>
#include <cstdint>
#include <cuchar>
export module std;

// https://en.cppreference.com/w/cpp/symbol_index
// https://en.cppreference.com/w/cpp/standard_library
// https://en.cppreference.com/w/cpp/feature_test#Library_features
// https://libcxx.llvm.org/Status/Ranges.html

export
{
    using ::operator new;
}

export namespace std
{
    using std::operator <<;
    using std::operator >>;
    using std::operator +;
    using std::operator -;
    using std::operator *;
    using std::operator /;
    using std::operator <;
    using std::operator <=;
    using std::operator >;
    using std::operator >=;
    using std::operator ==;
    using std::operator !=;
    using std::operator <=>;
    using std::operator |;

    using std::abs;
    using std::abort;
    using std::accumulate;
    using std::acos;
    using std::acosf;
    using std::acosh;
    using std::acoshf;
    using std::acoshl;
    using std::acosl;
    using std::add_const;
    using std::add_const_t;
    using std::add_cv;
    using std::add_cv_t;
    using std::add_lvalue_reference;
    using std::add_lvalue_reference_t;
    using std::add_pointer;
    using std::add_pointer_t;
    using std::add_rvalue_reference;
    using std::add_rvalue_reference_t;
    using std::add_volatile;
    using std::add_volatile_t;
    using std::addressof;
    using std::adjacent_difference;
    using std::adjacent_find;
    using std::adopt_lock;
    using std::adopt_lock_t;
    using std::advance;
    using std::align;
    using std::align_val_t;
    using std::aligned_alloc;
    using std::aligned_storage;
    using std::aligned_storage_t;
    using std::aligned_union;
    using std::aligned_union_t;
    using std::alignment_of;
    using std::alignment_of_v;
    using std::all_of;
    using std::allocate_shared;
    using std::allocator;
    using std::allocator_arg;
    using std::allocator_arg_t;
    using std::allocator_traits;
    using std::any;
    using std::any_cast;
    using std::any_of;
    using std::apply;
    using std::arg;
    using std::array;
    using std::as_bytes;
    using std::as_const;
    using std::as_writable_bytes;
    using std::asctime;
    using std::asin;
    using std::asinf;
    using std::asinh;
    using std::asinhf;
    using std::asinhl;
    using std::asinl;
    using std::assignable_from;
    using std::assume_aligned;
    using std::async;
    using std::at_quick_exit;
    using std::atan;
    using std::atan2;
    using std::atan2f;
    using std::atan2l;
    using std::atanf;
    using std::atanh;
    using std::atanhf;
    using std::atanhl;
    using std::atanl;
    using std::atexit;
    using std::atof;
    using std::atoi;
    using std::atol;
    using std::atoll;
    using std::atomic;
    using std::atomic_bool;
    using std::atomic_compare_exchange_strong;
    using std::atomic_compare_exchange_strong_explicit;
    using std::atomic_compare_exchange_weak;
    using std::atomic_compare_exchange_weak_explicit;
    using std::atomic_exchange;
    using std::atomic_exchange_explicit;
    using std::atomic_fetch_add;
    using std::atomic_fetch_add_explicit;
    using std::atomic_fetch_and;
    using std::atomic_fetch_and_explicit;
    using std::atomic_fetch_or;
    using std::atomic_fetch_or_explicit;
    using std::atomic_fetch_sub;
    using std::atomic_fetch_sub_explicit;
    using std::atomic_fetch_xor;
    using std::atomic_fetch_xor_explicit;
    using std::atomic_flag;
    using std::atomic_flag_clear;
    using std::atomic_flag_clear_explicit;
    using std::atomic_flag_notify_all;
    using std::atomic_flag_notify_one;
    using std::atomic_flag_test;
    using std::atomic_flag_test_and_set;
    using std::atomic_flag_test_and_set_explicit;
    using std::atomic_flag_test_explicit;
    using std::atomic_flag_wait;
    using std::atomic_flag_wait_explicit;
    using std::atomic_init;
    using std::atomic_is_lock_free;
    using std::atomic_load;
    using std::atomic_load_explicit;
    using std::atomic_notify_all;
    using std::atomic_notify_one;
    using std::atomic_signal_fence;
    using std::atomic_store;
    using std::atomic_store_explicit;
    using std::atomic_thread_fence;
    using std::atomic_wait;
    using std::atomic_wait_explicit;
    using std::atto;
    using std::back_insert_iterator;
    using std::back_inserter;
    using std::bad_alloc;
    using std::bad_any_cast;
    using std::bad_array_new_length;
    using std::bad_cast;
    using std::bad_exception;
    using std::bad_function_call;
    using std::bad_optional_access;
    using std::bad_typeid;
    using std::bad_variant_access;
    using std::bad_weak_ptr;
    using std::barrier;
    using std::basic_common_reference;
    using std::basic_filebuf;
    using std::basic_format_arg;
    using std::basic_format_args;
    using std::basic_format_context;
    using std::basic_format_parse_context;
    using std::basic_format_string;
    using std::basic_fstream;
    using std::basic_ifstream;
    using std::basic_ios;
    using std::basic_iostream;
    using std::basic_istream;
    using std::basic_istringstream;
    using std::basic_ofstream;
    using std::basic_ostream;
    using std::basic_ostringstream;
    using std::basic_regex;
    using std::basic_streambuf;
    using std::basic_string;
    using std::basic_string_view;
    using std::basic_stringbuf;
    using std::basic_stringstream;
    using std::begin;
    using std::bernoulli_distribution;
    using std::bidirectional_iterator;
    using std::bidirectional_iterator_tag;
    using std::binary_search;
    using std::binary_semaphore;
    using std::bind;
    using std::bind_front;
    using std::binomial_distribution;
    using std::bit_and;
    using std::bit_cast;
    using std::bit_ceil;
    using std::bit_floor;
    using std::bit_not;
    using std::bit_or;
    using std::bit_width;
    using std::bit_xor;
    using std::bitset;
    using std::bool_constant;
    using std::boolalpha;
    using std::boyer_moore_horspool_searcher;
    using std::boyer_moore_searcher;
    using std::bsearch;
    using std::btowc;
    using std::byte;
    // using std::c16rtomb;
    // using std::c32rtomb;
    // using std::c8rtomb;
    using std::call_once;
    using std::calloc;
    using std::cauchy_distribution;
    using std::cbegin;
    using std::cbrt;
    using std::cbrtf;
    using std::cbrtl;
    using std::ceil;
    using std::ceilf;
    using std::ceill;
    using std::cend;
    using std::centi;
    using std::cerr;
    using std::char_traits;
    using std::chars_format;
    using std::chi_squared_distribution;
    using std::cin;
    using std::clamp;
    using std::clearerr;
    using std::clock;
    using std::clock_t;
    using std::clog;
    using std::cmatch;
    using std::cmp_equal;
    using std::cmp_greater;
    using std::cmp_greater_equal;
    using std::cmp_less;
    using std::cmp_less_equal;
    using std::cmp_not_equal;
    using std::codecvt;
    using std::codecvt_base;
    using std::codecvt_byname;
    using std::codecvt_mode;
    using std::codecvt_utf16;
    using std::codecvt_utf8;
    using std::codecvt_utf8_utf16;
    using std::collate;
    using std::collate_byname;
    using std::common_comparison_category;
    using std::common_comparison_category_t;
    using std::common_iterator;
    using std::common_reference;
    using std::common_reference_t;
    using std::common_reference_with;
    using std::common_type;
    using std::common_type_t;
    using std::common_with;
    using std::compare_partial_order_fallback;
    using std::compare_strong_order_fallback;
    using std::compare_three_way;
    using std::compare_three_way_result;
    using std::compare_three_way_result_t;
    using std::compare_weak_order_fallback;
    using std::complex;
    using std::condition_variable;
    using std::condition_variable_any;
    using std::conditional;
    using std::conditional_t;
    using std::conj;
    using std::conjunction;
    using std::conjunction_v;
    using std::const_pointer_cast;
    using std::construct_at;
    using std::constructible_from;
    using std::consume_header;
    using std::contiguous_iterator;
    using std::contiguous_iterator_tag;
    using std::convertible_to;
    using std::copy;
    using std::copy_backward;
    using std::copy_constructible;
    using std::copy_if;
    using std::copy_n;
    using std::copyable;
    using std::copysign;
    using std::copysignf;
    using std::copysignl;
    using std::coroutine_handle;
    using std::coroutine_traits;
    using std::cos;
    using std::cosf;
    using std::cosh;
    using std::coshf;
    using std::coshl;
    using std::cosl;
    using std::count;
    using std::count_if;
    using std::counted_iterator;
    using std::counting_semaphore;
    using std::countl_one;
    using std::countl_zero;
    using std::countr_one;
    using std::countr_zero;
    using std::cout;
    using std::crbegin;
    using std::cref;
    using std::cregex_iterator;
    using std::cregex_token_iterator;
    using std::crend;
    using std::csub_match;
    using std::ctime;
    using std::ctype;
    using std::ctype_base;
    using std::ctype_byname;
    using std::current_exception;
    using std::cv_status;
    using std::data;
    using std::dec;
    using std::deca;
    using std::decay;
    using std::decay_t;
    using std::deci;
    using std::declval;
    using std::default_delete;
    using std::default_initializable;
    using std::default_random_engine;
    using std::default_searcher;
    using std::default_sentinel;
    using std::default_sentinel_t;
    using std::defaultfloat;
    using std::defer_lock;
    using std::defer_lock_t;
    using std::denorm_absent;
    using std::denorm_indeterminate;
    using std::denorm_present;
    using std::deque;
    using std::derived_from;
    using std::destroy;
    using std::destroy_at;
    using std::destroy_n;
    using std::destroying_delete;
    using std::destroying_delete_t;
    using std::destructible;
    using std::difftime;
    using std::disable_sized_sentinel_for;
    using std::discard_block_engine;
    using std::discrete_distribution;
    using std::disjunction;
    using std::disjunction_v;
    using std::distance;
    using std::div;
    using std::div_t;
    using std::divides;
    using std::domain_error;
    using std::double_t;
    using std::dynamic_extent;
    using std::dynamic_pointer_cast;
    using std::empty;
    using std::enable_if;
    using std::enable_if_t;
    using std::enable_shared_from_this;
    using std::end;
    using std::endian;
    using std::endl;
    using std::ends;
    using std::equal;
    using std::equal_range;
    using std::equal_to;
    using std::equality_comparable;
    using std::equality_comparable_with;
    using std::equivalence_relation;
    using std::erase;
    using std::erase_if;
    using std::erf;
    using std::erfc;
    using std::erfcf;
    using std::erfcl;
    using std::erff;
    using std::erfl;
    using std::errc;
    using std::error_category;
    using std::error_code;
    using std::error_condition;
    using std::exa;
    using std::exception;
    using std::exception_ptr;
    using std::exchange;
    using std::exclusive_scan;
    using std::exit;
    using std::exp;
    using std::exp2;
    using std::exp2f;
    using std::exp2l;
    using std::expf;
    using std::expl;
    using std::expm1;
    using std::expm1f;
    using std::expm1l;
    using std::exponential_distribution;
    using std::extent;
    using std::extent_v;
    using std::extreme_value_distribution;
    using std::fabs;
    using std::fabsf;
    using std::fabsl;
    using std::false_type;
    using std::fclose;
    using std::fdim;
    using std::fdimf;
    using std::fdiml;
    using std::feclearexcept;
    using std::fegetenv;
    using std::fegetexceptflag;
    using std::fegetround;
    using std::feholdexcept;
    using std::femto;
    using std::fenv_t;
    using std::feof;
    using std::feraiseexcept;
    using std::ferror;
    using std::fesetenv;
    using std::fesetexceptflag;
    using std::fesetround;
    using std::fetestexcept;
    using std::feupdateenv;
    using std::fexcept_t;
    using std::fflush;
    using std::fgetc;
    using std::fgetpos;
    using std::fgets;
    using std::fgetwc;
    using std::fgetws;
    using std::FILE;
    using std::filebuf;
    using std::fill;
    using std::fill_n;
    using std::find;
    using std::find_end;
    using std::find_first_of;
    using std::find_if;
    using std::find_if_not;
    using std::fisher_f_distribution;
    using std::fixed;
    
    #ifdef __cpp_lib_flat_map
    using std::flat_map;
    // using std::flat_multimap_map; // FIXMEs
    #endif

    using std::float_denorm_style;
    using std::float_round_style;
    using std::float_t;
    using std::floating_point;
    using std::floor;
    using std::floorf;
    using std::floorl;
    using std::flush;
    using std::fma;
    using std::fmaf;
    using std::fmal;
    using std::fmax;
    using std::fmaxf;
    using std::fmaxl;
    using std::fmin;
    using std::fminf;
    using std::fminl;
    using std::fmod;
    using std::fmodf;
    using std::fmodl;
    using std::fopen;
    using std::for_each;
    using std::for_each_n;
    using std::format;
    using std::format_args;
    using std::format_context;
    using std::format_error;
    using std::format_parse_context;
    using std::format_string;
    using std::format_to;
    using std::format_to_n;
    using std::format_to_n_result;
    using std::formatted_size;
    using std::formatter;
    using std::forward;
    using std::forward_as_tuple;
    using std::forward_iterator;
    using std::forward_iterator_tag;
    using std::forward_list;
    using std::fpclassify;
    using std::fpos;
    using std::fpos_t;
    using std::fprintf;
    using std::fputc;
    using std::fputs;
    using std::fputwc;
    using std::fputws;
    using std::fread;
    using std::free;
    using std::freopen;
    using std::frexp;
    using std::frexpf;
    using std::frexpl;
    using std::from_chars;
    using std::from_chars_result;
    using std::front_insert_iterator;
    using std::front_inserter;
    using std::fscanf;
    using std::fseek;
    using std::fsetpos;
    using std::fstream;
    using std::ftell;
    using std::function;
    using std::future;
    using std::future_category;
    using std::future_errc;
    using std::future_error;
    using std::future_status;
    using std::fwide;
    using std::fwprintf;
    using std::fwrite;
    using std::fwscanf;
    using std::gamma_distribution;
    using std::gcd;
    using std::generate;
    using std::generate_canonical;
    using std::generate_header;
    using std::generate_n;
    using std::generic_category;
    using std::geometric_distribution;
    using std::get;
    using std::get_deleter;
    using std::get_if;
    using std::get_money;
    using std::get_new_handler;
    using std::get_terminate;
    using std::get_time;
    using std::getc;
    using std::getchar;
    using std::getenv;
    using std::getline;
    using std::getwc;
    using std::getwchar;
    using std::giga;
    using std::gmtime;
    using std::greater;
    using std::greater_equal;
    using std::gslice;
    using std::gslice_array;
    using std::has_facet;
    using std::has_single_bit;
    using std::has_unique_object_representations;
    using std::has_unique_object_representations_v;
    using std::has_virtual_destructor;
    using std::has_virtual_destructor_v;
    using std::hash;
    using std::hecto;
    using std::hex;
    using std::hexfloat;
    using std::holds_alternative;
    using std::hypot;
    using std::hypotf;
    using std::hypotl;
    using std::identity;
    using std::ifstream;
    using std::ignore;
    using std::ilogb;
    using std::ilogbf;
    using std::ilogbl;
    using std::imag;
    using std::imaxabs;
    using std::imaxdiv;
    using std::imaxdiv_t;
    using std::in_place;
    using std::in_place_index;
    using std::in_place_index_t;
    using std::in_place_t;
    using std::in_place_type;
    using std::in_place_type_t;
    using std::in_range;
    using std::includes;
    using std::inclusive_scan;
    using std::incrementable;
    using std::incrementable_traits;
    using std::independent_bits_engine;
    using std::indirect_array;
    using std::indirect_binary_predicate;
    using std::indirect_equivalence_relation;
    using std::indirect_result_t;
    using std::indirect_strict_weak_order;
    using std::indirect_unary_predicate;
    using std::indirectly_comparable;
    using std::indirectly_copyable;
    using std::indirectly_copyable_storable;
    using std::indirectly_movable;
    using std::indirectly_movable_storable;
    using std::indirectly_readable;
    using std::indirectly_readable_traits;
    using std::indirectly_regular_unary_invocable;
    using std::indirectly_swappable;
    using std::indirectly_unary_invocable;
    using std::indirectly_writable;
    using std::initializer_list;
    using std::inner_product;
    using std::inplace_merge;
    using std::input_iterator;
    using std::input_iterator_tag;
    using std::input_or_output_iterator;
    using std::insert_iterator;
    using std::inserter;
    using std::int_fast16_t;
    using std::int_fast32_t;
    using std::int_fast64_t;
    using std::int_fast8_t;
    using std::int_least16_t;
    using std::int_least32_t;
    using std::int_least64_t;
    using std::int_least8_t;
    using std::int16_t;
    using std::int32_t;
    using std::int64_t;
    using std::int8_t;
    using std::index_sequence;
    using std::integer_sequence;
    using std::integral;
    using std::integral_constant;
    using std::internal;
    using std::intmax_t;
    using std::intptr_t;
    using std::invalid_argument;
    using std::invocable;
    using std::invoke;
    using std::invoke_result;
    using std::invoke_result_t;
    using std::io_errc;
    using std::ios;
    using std::ios_base;
    using std::iostream;
    using std::iostream_category;
    using std::iota;
    using std::is_abstract;
    using std::is_abstract_v;
    using std::is_aggregate;
    using std::is_aggregate_v;
    using std::is_arithmetic;
    using std::is_arithmetic_v;
    using std::is_array;
    using std::is_array_v;
    using std::is_assignable;
    using std::is_assignable_v;
    using std::is_base_of;
    using std::is_base_of_v;
    using std::is_bind_expression;
    using std::is_bind_expression_v;
    using std::is_bounded_array;
    using std::is_bounded_array_v;
    using std::is_class;
    using std::is_class_v;
    using std::is_compound;
    using std::is_compound_v;
    using std::is_const;
    using std::is_const_v;
    using std::is_constant_evaluated;
    using std::is_constructible;
    using std::is_constructible_v;
    using std::is_convertible;
    using std::is_convertible_v;
    using std::is_copy_assignable;
    using std::is_copy_assignable_v;
    using std::is_copy_constructible;
    using std::is_copy_constructible_v;
    using std::is_default_constructible;
    using std::is_default_constructible_v;
    using std::is_destructible;
    using std::is_destructible_v;
    using std::is_empty;
    using std::is_empty_v;
    using std::is_enum;
    using std::is_enum_v;
    using std::is_eq;
    using std::is_error_code_enum;
    using std::is_error_condition_enum;
    using std::is_error_condition_enum_v;
    using std::is_final;
    using std::is_final_v;
    using std::is_floating_point;
    using std::is_floating_point_v;
    using std::is_function;
    using std::is_function_v;
    using std::is_fundamental;
    using std::is_fundamental_v;
    using std::is_gt;
    using std::is_gteq;
    using std::is_heap;
    using std::is_heap_until;
    using std::is_integral;
    using std::is_integral_v;
    using std::is_invocable;
    using std::is_invocable_r;
    using std::is_invocable_r_v;
    using std::is_invocable_v;
    using std::is_lteq;
    using std::is_lvalue_reference;
    using std::is_lvalue_reference_v;
    using std::is_member_function_pointer;
    using std::is_member_function_pointer_v;
    using std::is_member_object_pointer;
    using std::is_member_object_pointer_v;
    using std::is_member_pointer;
    using std::is_member_pointer_v;
    using std::is_move_assignable;
    using std::is_move_assignable_v;
    using std::is_move_constructible;
    using std::is_move_constructible_v;
    using std::is_neq;
    using std::is_nothrow_assignable;
    using std::is_nothrow_assignable_v;
    using std::is_nothrow_constructible;
    using std::is_nothrow_constructible_v;
    using std::is_nothrow_convertible;
    using std::is_nothrow_convertible_v;
    using std::is_nothrow_copy_assignable;
    using std::is_nothrow_copy_assignable_v;
    using std::is_nothrow_copy_constructible;
    using std::is_nothrow_copy_constructible_v;
    using std::is_nothrow_default_constructible;
    using std::is_nothrow_default_constructible_v;
    using std::is_nothrow_destructible;
    using std::is_nothrow_destructible_v;
    using std::is_nothrow_invocable;
    using std::is_nothrow_invocable_r;
    using std::is_nothrow_invocable_r_v;
    using std::is_nothrow_invocable_v;
    using std::is_nothrow_move_assignable;
    using std::is_nothrow_move_assignable_v;
    using std::is_nothrow_move_constructible;
    using std::is_nothrow_move_constructible_v;
    using std::is_nothrow_swappable;
    using std::is_nothrow_swappable_v;
    using std::is_nothrow_swappable_with;
    using std::is_nothrow_swappable_with_v;
    using std::is_null_pointer;
    using std::is_null_pointer_v;
    using std::is_object;
    using std::is_object_v;
    using std::is_partitioned;
    using std::is_permutation;
    using std::is_placeholder;
    using std::is_placeholder_v;
    using std::is_pod;
    using std::is_pod_v;
    using std::is_pointer;
    using std::is_pointer_v;
    using std::is_polymorphic;
    using std::is_polymorphic_v;
    using std::is_reference;
    using std::is_reference_v;
    using std::is_rvalue_reference;
    using std::is_rvalue_reference_v;
    using std::is_same;
    using std::is_same_v;
    using std::is_scalar;
    using std::is_scalar_v;
    using std::is_signed;
    using std::is_signed_v;
    using std::is_sorted;
    using std::is_sorted_until;
    using std::is_standard_layout;
    using std::is_standard_layout_v;
    using std::is_swappable;
    using std::is_swappable_v;
    using std::is_swappable_with;
    using std::is_swappable_with_v;
    using std::is_trivial;
    using std::is_trivial_v;
    using std::is_trivially_assignable;
    using std::is_trivially_assignable_v;
    using std::is_trivially_constructible;
    using std::is_trivially_constructible_v;
    using std::is_trivially_copy_assignable;
    using std::is_trivially_copy_assignable_v;
    using std::is_trivially_copy_constructible;
    using std::is_trivially_copy_constructible_v;
    using std::is_trivially_copyable;
    using std::is_trivially_copyable_v;
    using std::is_trivially_default_constructible;
    using std::is_trivially_default_constructible_v;
    using std::is_trivially_destructible;
    using std::is_trivially_destructible_v;
    using std::is_trivially_move_assignable;
    using std::is_trivially_move_assignable_v;
    using std::is_trivially_move_constructible;
    using std::is_trivially_move_constructible_v;
    using std::is_unbounded_array;
    using std::is_unbounded_array_v;
    using std::is_union;
    using std::is_union_v;
    using std::is_unsigned;
    using std::is_unsigned_v;
    using std::is_void;
    using std::is_void_v;
    using std::is_volatile;
    using std::is_volatile_v;
    using std::isalnum;
    using std::isalpha;
    using std::isblank;
    using std::iscntrl;
    using std::isdigit;
    using std::isfinite;
    using std::isgraph;
    using std::isgreater;
    using std::isgreaterequal;
    using std::isinf;
    using std::isless;
    using std::islessequal;
    using std::islessgreater;
    using std::islower;
    using std::isnan;
    using std::isnormal;
    using std::isprint;
    using std::ispunct;
    using std::isspace;
    using std::istream;
    using std::istream_iterator;
    using std::istreambuf_iterator;
    using std::istringstream;
    using std::istrstream;
    using std::isunordered;
    using std::isupper;
    using std::iswalnum;
    using std::iswalpha;
    using std::iswblank;
    using std::iswcntrl;
    using std::iswctype;
    using std::iswdigit;
    using std::iswgraph;
    using std::iswlower;
    using std::iswprint;
    using std::iswpunct;
    using std::iswspace;
    using std::iswupper;
    using std::iswxdigit;
    using std::isxdigit;
    using std::iter_common_reference_t;
    using std::iter_difference_t;
    using std::iter_reference_t;
    using std::iter_rvalue_reference_t;
    using std::iter_swap;
    using std::iter_value_t;
    using std::iterator;
    using std::iterator_traits;
    using std::jmp_buf;
    using std::kill_dependency;
    using std::kilo;
    using std::knuth_b;
    using std::labs;
    using std::latch;
    using std::launch;
    using std::launder;
    using std::lcm;
    using std::lconv;
    using std::ldexp;
    using std::ldexpf;
    using std::ldexpl;
    using std::ldiv;
    using std::ldiv_t;
    using std::left;
    using std::length_error;
    using std::lerp;
    using std::less;
    using std::less_equal;
    using std::lexicographical_compare;
    using std::lgamma;
    using std::lgammaf;
    using std::lgammal;
    using std::linear_congruential_engine;
    using std::list;
    using std::little_endian;
    using std::llabs;
    using std::lldiv;
    using std::lldiv_t;
    using std::llrint;
    using std::llrintf;
    using std::llrintl;
    using std::llround;
    using std::llroundf;
    using std::llroundl;
    using std::locale;
    using std::localeconv;
    using std::localtime;
    using std::lock;
    using std::lock_guard;
    using std::log;
    using std::log10;
    using std::log10f;
    using std::log10l;
    using std::log1p;
    using std::log1pf;
    using std::log1pl;
    using std::log2;
    using std::log2f;
    using std::log2l;
    using std::logb;
    using std::logbf;
    using std::logbl;
    using std::logf;
    using std::logic_error;
    using std::logical_and;
    using std::logical_not;
    using std::logical_or;
    using std::logl;
    using std::lognormal_distribution;
    using std::longjmp;
    using std::lower_bound;
    using std::lrint;
    using std::lrintf;
    using std::lrintl;
    using std::lround;
    using std::lroundf;
    using std::lroundl;
    using std::make_any;
    using std::make_error_code;
    using std::make_error_condition;
    using std::make_exception_ptr;
    using std::make_format_args;
    using std::make_from_tuple;
    using std::make_heap;
    using std::make_index_sequence;
    using std::make_move_iterator;
    using std::make_obj_using_allocator;
    using std::make_optional;
    using std::make_pair;
    using std::make_reverse_iterator;
    using std::make_shared;
    using std::make_signed;
    using std::make_signed_t;
    using std::make_tuple;
    using std::make_unique;
    using std::make_unsigned;
    using std::make_unsigned_t;
    using std::make_wformat_args;
    using std::malloc;
    using std::map;
    using std::mask_array;
    using std::match_results;
    using std::max;
    using std::max_align_t;
    using std::max_element;
    using std::mblen;
    using std::mbrlen;
    // using std::mbrtoc16;
    // using std::mbrtoc32;
    // using std::mbrtoc8;
    using std::mbrtowc;
    using std::mbsinit;
    using std::mbsrtowcs;
    using std::mbstate_t;
    using std::mbstowcs;
    using std::mbtowc;
    using std::mega;
    using std::mem_fn;
    using std::memchr;
    using std::memcmp;
    using std::memcpy;
    using std::memmove;
    using std::memory_order;
    using std::memory_order_acq_rel;
    using std::memory_order_acquire;
    using std::memory_order_consume;
    using std::memory_order_relaxed;
    using std::memory_order_release;
    using std::memory_order_seq_cst;
    using std::memset;
    using std::merge;
    using std::mergeable;
    using std::mersenne_twister_engine;
    using std::messages;
    using std::messages_base;
    using std::messages_byname;
    using std::micro;
    using std::midpoint;
    using std::milli;
    using std::min;
    using std::min_element;
    using std::minmax;
    using std::minmax_element;
    using std::minstd_rand;
    using std::minstd_rand0;
    using std::minus;
    using std::mismatch;
    using std::mktime;
    using std::modf;
    using std::modff;
    using std::modfl;
    using std::modulus;
    using std::money_base;
    using std::money_get;
    using std::money_put;
    using std::moneypunct;
    using std::moneypunct_byname;
    using std::monostate;
    using std::movable;
    using std::move;
    using std::move_backward;
    using std::move_constructible;
    using std::move_if_noexcept;
    using std::move_iterator;
    using std::move_sentinel;
    using std::mt19937;
    using std::mt19937_64;
    using std::multimap;
    using std::multiplies;
    using std::multiset;
    using std::mutex;
    using std::nan;
    using std::nanf;
    using std::nanl;
    using std::nano;
    using std::nearbyint;
    using std::nearbyintf;
    using std::nearbyintl;
    using std::negate;
    using std::negation;
    using std::negation_v;
    using std::negative_binomial_distribution;
    using std::nested_exception;
    using std::new_handler;
    using std::next;
    using std::next_permutation;
    using std::nextafter;
    using std::nextafterf;
    using std::nextafterl;
    using std::nexttoward;
    using std::nexttowardf;
    using std::nexttowardl;
    using std::noboolalpha;
    // using std::noemit_on_flush;
    using std::none_of;
    using std::noop_coroutine;
    using std::noop_coroutine_handle;
    using std::noop_coroutine_promise;
    using std::norm;
    using std::normal_distribution;
    using std::noshowbase;
    using std::noshowpoint;
    using std::noshowpos;
    using std::noskipws;
    using std::not_equal_to;
    using std::not_fn;
    using std::nothrow;
    using std::nothrow_t;
    using std::notify_all_at_thread_exit;
    using std::nounitbuf;
    using std::nouppercase;
    using std::nth_element;
    using std::nullopt;
    using std::nullopt_t;
    using std::nullptr_t;
    using std::num_get;
    using std::num_put;
    using std::numeric_limits;
    using std::numpunct;
    using std::numpunct_byname;
    using std::oct;
    using std::ofstream;
    using std::once_flag;
    using std::optional;
    using std::ostream;
    using std::ostream_iterator;
    using std::ostreambuf_iterator;
    using std::ostringstream;
    using std::ostrstream;
    using std::out_of_range;
    using std::output_iterator;
    using std::output_iterator_tag;
    using std::overflow_error;
    using std::owner_less;
    using std::packaged_task;
    using std::pair;
    using std::partial_order;
    using std::partial_ordering;
    using std::partial_sort;
    using std::partial_sort_copy;
    using std::partial_sum;
    using std::partition;
    using std::partition_copy;
    using std::partition_point;
    using std::permutable;
    using std::perror;
    using std::peta;
    using std::pico;
    using std::piecewise_constant_distribution;
    using std::piecewise_construct;
    using std::piecewise_construct_t;
    using std::piecewise_linear_distribution;
    using std::plus;
    using std::pointer_traits;
    using std::poisson_distribution;
    using std::polar;
    using std::pop_heap;
    using std::popcount;
    using std::pow;
    using std::powf;
    using std::powl;
    using std::predicate;
    using std::prev;
    using std::prev_permutation;
    using std::printf;
    using std::priority_queue;
    using std::proj;
    using std::projected;
    using std::promise;
    using std::ptrdiff_t;
    using std::push_heap;
    using std::put_money;
    using std::put_time;
    using std::putc;
    using std::putchar;
    using std::puts;
    using std::putwc;
    using std::putwchar;
    using std::qsort;
    using std::queue;
    using std::quick_exit;
    using std::quoted;
    using std::raise;
    using std::rand;
    using std::random_access_iterator;
    using std::random_access_iterator_tag;
    using std::random_device;
    using std::range_error;
    using std::rank;
    using std::rank_v;
    using std::ranlux24;
    using std::ranlux24_base;
    using std::ranlux48;
    using std::ranlux48_base;
    using std::ratio;
    using std::ratio_add;
    using std::ratio_divide;
    using std::ratio_equal;
    using std::ratio_equal_v;
    using std::ratio_greater;
    using std::ratio_greater_equal;
    using std::ratio_greater_equal_v;
    using std::ratio_greater_v;
    using std::ratio_less;
    using std::ratio_less_equal;
    using std::ratio_less_equal_v;
    using std::ratio_less_v;
    using std::ratio_multiply;
    using std::ratio_not_equal;
    using std::ratio_not_equal_v;
    using std::ratio_subtract;
    using std::rbegin;
    using std::real;
    using std::realloc;
    using std::recursive_mutex;
    using std::recursive_timed_mutex;
    using std::reduce;
    using std::ref;
    using std::reference_wrapper;
    using std::regex;
    using std::regex_error;
    using std::regex_iterator;
    using std::regex_match;
    using std::regex_replace;
    using std::regex_search;
    using std::regex_token_iterator;
    using std::regex_traits;
    using std::regular;
    using std::regular_invocable;
    using std::reinterpret_pointer_cast;
    using std::relation;
    using std::remainder;
    using std::remainderf;
    using std::remainderl;
    using std::remove;
    using std::remove_all_extents;
    using std::remove_all_extents_t;
    using std::remove_const;
    using std::remove_const_t;
    using std::remove_copy;
    using std::remove_copy_if;
    using std::remove_cv;
    using std::remove_cv_t;
    using std::remove_cvref;
    using std::remove_cvref_t;
    using std::remove_extent;
    using std::remove_extent_t;
    using std::remove_if;
    using std::remove_pointer;
    using std::remove_pointer_t;
    using std::remove_reference;
    using std::remove_reference_t;
    using std::remove_volatile;
    using std::remove_volatile_t;
    using std::remquo;
    using std::remquof;
    using std::remquol;
    using std::rename;
    using std::rend;
    using std::replace;
    using std::replace_copy;
    using std::replace_copy_if;
    using std::replace_if;
    using std::resetiosflags;
    using std::rethrow_exception;
    using std::rethrow_if_nested;
    using std::reverse;
    using std::reverse_copy;
    using std::reverse_iterator;
    using std::rewind;
    using std::right;
    using std::rint;
    using std::rintf;
    using std::rintl;
    using std::rotate;
    using std::rotate_copy;
    using std::rotl;
    using std::rotr;
    using std::round;
    using std::round_indeterminate;
    using std::round_to_nearest;
    using std::round_toward_infinity;
    using std::round_toward_neg_infinity;
    using std::round_toward_zero;
    using std::roundf;
    using std::roundl;
    using std::runtime_error;
    using std::same_as;
    using std::sample;
    using std::scalbln;
    using std::scalblnf;
    using std::scalblnl;
    using std::scalbn;
    using std::scalbnf;
    using std::scalbnl;
    using std::scanf;
    using std::scientific;
    using std::scoped_allocator_adaptor;
    using std::scoped_lock;
    using std::search;
    using std::search_n;
    using std::seed_seq;
    using std::semiregular;
    using std::sentinel_for;
    using std::set;
    using std::set_difference;
    using std::set_intersection;
    using std::set_new_handler;
    using std::set_symmetric_difference;
    using std::set_terminate;
    using std::set_union;
    using std::setbase;
    using std::setbuf;
    using std::setfill;
    using std::setiosflags;
    using std::setlocale;
    using std::setprecision;
    using std::setvbuf;
    using std::setw;
    using std::shared_future;
    using std::shared_lock;
    using std::shared_mutex;
    using std::shared_ptr;
    using std::shared_timed_mutex;
    using std::shift_left;
    using std::shift_right;
    using std::showbase;
    using std::showpoint;
    using std::showpos;
    using std::shuffle;
    using std::shuffle_order_engine;
    using std::sig_atomic_t;
    using std::signal;
    using std::signbit;
    using std::signed_integral;
    using std::sin;
    using std::sinf;
    using std::sinh;
    using std::sinhf;
    using std::sinhl;
    using std::sinl;
    using std::size;
    using std::size_t;
    using std::sized_sentinel_for;
    using std::skipws;
    using std::slice;
    using std::slice_array;
    using std::smatch;
    using std::snprintf;
    using std::sort;
    using std::sort_heap;
    using std::sortable;
    using std::span;
    using std::sprintf;
    using std::sqrt;
    using std::sqrtf;
    using std::sqrtl;
    using std::srand;
    using std::sregex_iterator;
    using std::sregex_token_iterator;
    using std::sscanf;
    using std::ssize;
    using std::ssub_match;
    using std::stable_partition;
    using std::stable_sort;
    using std::stack;
    using std::static_pointer_cast;
    using std::stod;
    using std::stof;
    using std::stoi;
    using std::stol;
    using std::stold;
    using std::stoll;
    using std::stoul;
    using std::stoull;
    using std::strcat;
    using std::strchr;
    using std::strcmp;
    using std::strcoll;
    using std::strcpy;
    using std::strcspn;
    using std::streambuf;
    using std::streamoff;
    using std::streampos;
    using std::streamsize;
    using std::strerror;
    using std::strftime;
    using std::strict_weak_order;
    using std::string;
    using std::string_view;
    using std::stringbuf;
    using std::stringstream;
    using std::strlen;
    using std::strncat;
    using std::strncmp;
    using std::strncpy;
    using std::strong_order;
    using std::strong_ordering;
    using std::strpbrk;
    using std::strrchr;
    using std::strspn;
    using std::strstr;
    using std::strstream;
    using std::strstreambuf;
    using std::strtod;
    using std::strtof;
    using std::strtoimax;
    using std::strtok;
    using std::strtol;
    using std::strtold;
    using std::strtoll;
    using std::strtoul;
    using std::strtoull;
    using std::strtoumax;
    using std::strxfrm;
    using std::student_t_distribution;
    using std::sub_match;
    using std::subtract_with_carry_engine;
    using std::suspend_always;
    using std::suspend_never;
    using std::swap;
    using std::swap_ranges;
    using std::swappable;
    using std::swappable_with;
    using std::swprintf;
    using std::swscanf;
    using std::system;
    using std::system_category;
    using std::system_error;
    using std::tan;
    using std::tanf;
    using std::tanh;
    using std::tanhf;
    using std::tanhl;
    using std::tanl;
    using std::tera;
    using std::terminate;
    using std::terminate_handler;
    using std::tgamma;
    using std::tgammaf;
    using std::tgammal;
    using std::thread;
    using std::three_way_comparable;
    using std::three_way_comparable_with;
    using std::throw_with_nested;
    using std::tie;
    using std::time;
    using std::time_base;
    using std::time_get;
    using std::time_get_byname;
    using std::time_put;
    using std::time_put_byname;
    using std::time_t;
    using std::timed_mutex;
    using std::timespec;
    using std::timespec_get;
    using std::tm;
    using std::tmpfile;
    using std::tmpnam;
    using std::to_address;
    using std::to_array;
    using std::to_chars;
    using std::to_chars_result;
    using std::to_integer;
    using std::to_string;
    using std::to_underlying;
    using std::to_wstring;
    using std::tolower;
    using std::totally_ordered;
    using std::totally_ordered_with;
    using std::toupper;
    using std::towctrans;
    using std::towlower;
    using std::towupper;
    using std::transform;
    using std::transform_exclusive_scan;
    using std::transform_inclusive_scan;
    using std::transform_reduce;
    using std::true_type;
    using std::trunc;
    using std::truncf;
    using std::truncl;
    using std::try_lock;
    using std::try_to_lock;
    using std::try_to_lock_t;
    using std::tuple;
    using std::tuple_cat;
    using std::tuple_element;
    using std::tuple_element_t;
    using std::tuple_size;
    using std::tuple_size_v;
    using std::type_identity;
    using std::type_identity_t;
    using std::type_index;
    using std::type_info;
    using std::u16streampos;
    using std::u16string;
    using std::u16string_view;
    using std::u32streampos;
    using std::u32string;
    using std::u32string_view;
    using std::u8streampos;
    using std::u8string;
    using std::u8string_view;
    using std::uint_fast16_t;
    using std::uint_fast32_t;
    using std::uint_fast64_t;
    using std::uint_fast8_t;
    using std::uint_least16_t;
    using std::uint_least32_t;
    using std::uint_least64_t;
    using std::uint_least8_t;
    using std::uint16_t;
    using std::uint32_t;
    using std::uint64_t;
    using std::uint8_t;
    using std::uintmax_t;
    using std::uintptr_t;
    using std::uncaught_exceptions;
    using std::underflow_error;
    using std::underlying_type;
    using std::underlying_type_t;
    using std::ungetc;
    using std::ungetwc;
    using std::uniform_int_distribution;
    using std::uniform_random_bit_generator;
    using std::uniform_real_distribution;
    using std::uninitialized_construct_using_allocator;
    using std::uninitialized_copy;
    using std::uninitialized_copy_n;
    using std::uninitialized_default_construct;
    using std::uninitialized_default_construct_n;
    using std::uninitialized_fill;
    using std::uninitialized_fill_n;
    using std::uninitialized_move;
    using std::uninitialized_move_n;
    using std::uninitialized_value_construct;
    using std::uninitialized_value_construct_n;
    using std::unique;
    using std::unique_copy;
    using std::unique_lock;
    using std::unique_ptr;
    using std::unitbuf;
    using std::unordered_map;
    using std::unordered_multimap;
    using std::unordered_multiset;
    using std::unordered_set;
#ifdef __cpp_lib_unreachable
    using std::unreachable;
#endif
    using std::unreachable_sentinel;
    using std::unreachable_sentinel_t;
    using std::unsigned_integral;
    using std::unwrap_ref_decay;
    using std::unwrap_ref_decay_t;
    using std::unwrap_reference;
    using std::unwrap_reference_t;
    using std::upper_bound;
    using std::uppercase;
    using std::use_facet;
    using std::uses_allocator;
    using std::uses_allocator_construction_args;
    using std::uses_allocator_v;
    using std::va_list;
    using std::valarray;
    using std::variant;
    using std::variant_alternative;
    using std::variant_alternative_t;
    using std::variant_npos;
    using std::variant_size;
    using std::variant_size_v;
    using std::vector;
    using std::vformat;
    using std::vformat_to;
    using std::vfprintf;
    using std::vfscanf;
    using std::vfwprintf;
    using std::vfwscanf;
    using std::visit;
    using std::visit_format_arg;
    using std::void_t;
    using std::vprintf;
    using std::vscanf;
    using std::vsnprintf;
    using std::vsprintf;
    using std::vsscanf;
    using std::vswprintf;
    using std::vswscanf;
    using std::vwprintf;
    using std::vwscanf;
    using std::wbuffer_convert;
    using std::wcerr;
    using std::wcin;
    using std::wclog;
    using std::wcmatch;
    using std::wcout;
    using std::wcregex_iterator;
    using std::wcregex_token_iterator;
    using std::wcrtomb;
    using std::wcscat;
    using std::wcschr;
    using std::wcscmp;
    using std::wcscoll;
    using std::wcscpy;
    using std::wcscspn;
    using std::wcsftime;
    using std::wcslen;
    using std::wcsncat;
    using std::wcsncmp;
    using std::wcsncpy;
    using std::wcspbrk;
    using std::wcsrchr;
    using std::wcsrtombs;
    using std::wcsspn;
    using std::wcsstr;
    using std::wcstod;
    using std::wcstof;
    using std::wcstoimax;
    using std::wcstok;
    using std::wcstol;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstombs;
    using std::wcstoul;
    using std::wcstoull;
    using std::wcstoumax;
    using std::wcsub_match;
    using std::wcsxfrm;
    using std::wctob;
    using std::wctomb;
    using std::wctrans;
    using std::wctrans_t;
    using std::wctype;
    using std::wctype_t;
    using std::weak_order;
    using std::weak_ordering;
    using std::weak_ptr;
    using std::weakly_incrementable;
    using std::weibull_distribution;
    using std::wfilebuf;
    using std::wformat_args;
    using std::wformat_context;
    using std::wformat_parse_context;
    using std::wformat_string;
    using std::wfstream;
    using std::wifstream;
    using std::wint_t;
    using std::wios;
    using std::wiostream;
    using std::wistream;
    using std::wistringstream;
    using std::wmemchr;
    using std::wmemcmp;
    using std::wmemcpy;
    using std::wmemmove;
    using std::wmemset;
    using std::wofstream;
    using std::wostream;
    using std::wostringstream;
    using std::wprintf;
    using std::wregex;
    using std::ws;
    using std::wscanf;
    using std::wsmatch;
    using std::wsregex_iterator;
    using std::wsregex_token_iterator;
    using std::wssub_match;
    using std::wstreambuf;
    using std::wstreampos;
    using std::wstring;
    using std::wstring_convert;
    using std::wstring_view;
    using std::wstringbuf;
    using std::wstringstream;
    // using std::yocto;
    // using std::yotta;
    // using std::zepto;
    // using std::zetta;

    #ifdef __cpp_lib_atomic_ref
    using std::atomic_ref;
    #endif

    #ifdef __cpp_lib_hardware_interference_size
    using std::hardware_constructive_interference_size;
    using std::hardware_destructive_interference_size;
    #endif

    #ifdef __cpp_lib_is_layout_compatible
    using std::is_corresponding_member;
    using std::is_layout_compatible;
    using std::is_layout_compatible_v;
    using std::is_lt;

    #endif

    #ifdef __cpp_lib_is_pointer_interconvertible
    using std::is_pointer_interconvertible_base_of;
    using std::is_pointer_interconvertible_base_of_v;
    using std::is_pointer_interconvertible_with_class;
    #endif

    #ifdef __cpp_lib_jthread
    using std::jthread;
    using std::nostopstate;
    using std::nostopstate_t;
    using std::stop_callback;
    using std::stop_source;
    using std::stop_token;
    #endif

    #ifdef __cpp_lib_source_location
    using std::source_location;
    #endif

    #ifdef __cpp_lib_smart_ptr_for_overwrite
    using std::allocate_shared_for_overwrite;
    using std::make_shared_for_overwrite;
    using std::make_unique_for_overwrite;
    #endif

    #ifdef __cpp_lib_syncbuf
    using std::basic_osyncstream;
    using std::basic_syncbuf;
    using std::osyncstream;
    using std::syncbuf;
    using std::wosyncstream;
    using std::wsyncbuf;
//  using std::emit_on_flush;
//  using std::flush_emit;
    #endif

    #ifdef __cpp_lib_three_way_comparison
    using std::lexicographical_compare_three_way;
    #endif

    namespace chrono
    {
        using std::chrono::operator <<;
        using std::chrono::operator +;
        using std::chrono::operator -;
        using std::chrono::operator /;
        using std::chrono::operator *;
        using std::chrono::operator <;
        using std::chrono::operator <=;
        using std::chrono::operator >;
        using std::chrono::operator >=;
        using std::chrono::operator ==;
        using std::chrono::operator <=>;

        using std::chrono::abs;
        using std::chrono::April;
        using std::chrono::August;
        using std::chrono::ceil;
        using std::chrono::ceil;
        using std::chrono::day;
        using std::chrono::days;
        using std::chrono::December;
        using std::chrono::duration;
        using std::chrono::duration_cast;
        using std::chrono::duration_values;
        using std::chrono::February;
        using std::chrono::file_clock;
        using std::chrono::floor;
        using std::chrono::floor;
        using std::chrono::Friday;
        using std::chrono::hh_mm_ss;
        using std::chrono::high_resolution_clock;
        using std::chrono::hours;
        using std::chrono::is_am;
        using std::chrono::is_pm;
        using std::chrono::January;
        using std::chrono::July;
        using std::chrono::June;
        using std::chrono::last;
        using std::chrono::last_spec;
        using std::chrono::make12;
        using std::chrono::make24;
        using std::chrono::March;
        using std::chrono::May;
        using std::chrono::microseconds;
        using std::chrono::milliseconds;
        using std::chrono::minutes;
        using std::chrono::Monday;
        using std::chrono::month;
        using std::chrono::month_day;
        using std::chrono::month_day_last;
        using std::chrono::month_weekday;
        using std::chrono::month_weekday_last;
        using std::chrono::nanoseconds;
        using std::chrono::November;
        using std::chrono::October;
        using std::chrono::round;
        using std::chrono::Saturday;
        using std::chrono::seconds;
        using std::chrono::September;
        using std::chrono::steady_clock;
        using std::chrono::Sunday;
        using std::chrono::sys_days;
        using std::chrono::sys_seconds;
        using std::chrono::sys_time;
        using std::chrono::system_clock;
        using std::chrono::Thursday;
        using std::chrono::time_point;
        using std::chrono::time_point_cast;
        using std::chrono::treat_as_floating_point;
        using std::chrono::treat_as_floating_point_v;
        using std::chrono::Tuesday;
        using std::chrono::Wednesday;
        using std::chrono::weekday;
        using std::chrono::weekday_indexed;
        using std::chrono::weekday_last;
        using std::chrono::year;
        using std::chrono::year_month;
        using std::chrono::year_month_day;
        using std::chrono::year_month_day_last;
        using std::chrono::year_month_weekday;
        using std::chrono::year_month_weekday_last;

#if __cpp_lib_chrono >= 201907L

        using std::chrono::ambiguous_local_time;
        using std::chrono::choose;
        using std::chrono::clock_cast;
        using std::chrono::clock_time_conversion;
        using std::chrono::current_zone;
        using std::chrono::file_clock;
        using std::chrono::file_seconds;
        using std::chrono::file_time;
        using std::chrono::get_leap_second_info;
        using std::chrono::get_tzdb;
        using std::chrono::get_tzdb_list;
        using std::chrono::gps_clock;
        using std::chrono::gps_seconds;
        using std::chrono::gps_time;
        using std::chrono::is_clock;
        using std::chrono::is_clock_v;
        using std::chrono::leap_second;
        using std::chrono::leap_second_info;
        using std::chrono::local_info;
        using std::chrono::local_t;
        using std::chrono::local_seconds;
        using std::chrono::local_time;
        using std::chrono::locate_zone;
        using std::chrono::nonexistent_local_time;
        using std::chrono::reload_tzdb;
        using std::chrono::remote_version;
        using std::chrono::sys_info;
        using std::chrono::tai_clock;
        using std::chrono::tai_seconds;
        using std::chrono::tai_time;
        using std::chrono::time_zone;
        using std::chrono::time_zone_link;
        using std::chrono::tzdb;
        using std::chrono::tzdb_list;
        using std::chrono::utc_clock;
        using std::chrono::utc_seconds;
        using std::chrono::utc_time;
        using std::chrono::zoned_seconds;
        using std::chrono::zoned_time;
        using std::chrono::zoned_traits;

#endif

#if __cpp_lib_format >= 202207L

    using std::chrono::from_stream;
    using std::chrono::local_time_format;
    using std::chrono::parse;

#endif

    }

#ifdef __cpp_lib_execution

    using std::is_execution_policy;
    using std::is_execution_policy_v;

    namespace execution
    {
        using std::execution::par;
        using std::execution::par_unseq;
        using std::execution::parallel_policy;
        using std::execution::parallel_unsequenced_policy;
        using std::execution::seq;
        using std::execution::sequenced_policy;
        using std::execution::unseq;
        using std::execution::unsequenced_policy;
    }

#endif

    namespace filesystem
    {
        using std::filesystem::absolute;
        using std::filesystem::begin;
        using std::filesystem::begin;
        using std::filesystem::canonical;
        using std::filesystem::copy;
        using std::filesystem::copy_file;
        using std::filesystem::copy_options;
        using std::filesystem::copy_symlink;
        using std::filesystem::create_directory;
        using std::filesystem::create_directory_symlink;
        using std::filesystem::create_directories;
        using std::filesystem::create_hard_link;
        using std::filesystem::create_symlink;
        using std::filesystem::current_path;
        using std::filesystem::directory_entry;
        using std::filesystem::directory_iterator;
        using std::filesystem::directory_options;
        using std::filesystem::end;
        using std::filesystem::end;
        using std::filesystem::equivalent;
        using std::filesystem::exists;
        using std::filesystem::file_size;
        using std::filesystem::file_status;
        using std::filesystem::filesystem_error;
        using std::filesystem::file_time_type;
        using std::filesystem::file_type;
        using std::filesystem::hard_link_count;
        using std::filesystem::hash_value;
        using std::filesystem::is_block_file;
        using std::filesystem::is_character_file;
        using std::filesystem::is_directory;
        using std::filesystem::is_empty;
        using std::filesystem::is_fifo;
        using std::filesystem::is_other;
        using std::filesystem::is_regular_file;
        using std::filesystem::is_socket;
        using std::filesystem::is_symlink;
        using std::filesystem::last_write_time;
        using std::filesystem::path;
        using std::filesystem::permissions;
        using std::filesystem::perms;
        using std::filesystem::perm_options;
        using std::filesystem::proximate;
        using std::filesystem::read_symlink;
        using std::filesystem::recursive_directory_iterator;
        using std::filesystem::relative;
        using std::filesystem::remove;
        using std::filesystem::remove_all;
        using std::filesystem::rename;
        using std::filesystem::resize_file;
        using std::filesystem::space;
        using std::filesystem::space_info;
        using std::filesystem::status;
        using std::filesystem::status_known;
        using std::filesystem::swap;
        using std::filesystem::symlink_status;
        using std::filesystem::temp_directory_path;
        using std::filesystem::u8path;
        using std::filesystem::weakly_canonical;
    }

    inline namespace literals
    {

        inline namespace string_literals
        {
            using std::literals::string_literals::operator""s;
        }

        inline namespace string_view_literals
        {
            using std::literals::string_view_literals::operator""sv;
        }

        inline namespace chrono_literals
        {
            using std::literals::chrono_literals::operator""d;
            using std::literals::chrono_literals::operator""h;
            using std::literals::chrono_literals::operator""min;
            using std::literals::chrono_literals::operator""ms;
            using std::literals::chrono_literals::operator""ns;
            using std::literals::chrono_literals::operator""s;
            using std::literals::chrono_literals::operator""us;
            using std::literals::chrono_literals::operator""y;
        }

        inline namespace complex_literals
        {
            using std::literals::complex_literals::operator""i;
            using std::literals::complex_literals::operator""if;
            using std::literals::complex_literals::operator""il;
        }
    }

    namespace numbers
    {
        using std::numbers::e_v;
        using std::numbers::egamma;
        using std::numbers::egamma_v;
        using std::numbers::inv_pi;
        using std::numbers::inv_pi_v;
        using std::numbers::inv_sqrt3;
        using std::numbers::inv_sqrt3_v;
        using std::numbers::inv_sqrtpi;
        using std::numbers::inv_sqrtpi_v;
        using std::numbers::ln10;
        using std::numbers::ln10_v;
        using std::numbers::ln2;
        using std::numbers::ln2_v;
        using std::numbers::log10e;
        using std::numbers::log10e_v;
        using std::numbers::log2e;
        using std::numbers::log2e_v;
        using std::numbers::phi;
        using std::numbers::phi_v;
        using std::numbers::pi;
        using std::numbers::pi_v;
        using std::numbers::sqrt2;
        using std::numbers::sqrt2_v;
        using std::numbers::sqrt3;
        using std::numbers::sqrt3_v;
    }

    namespace placeholders
    {
        //  error: using declaration referring to '_1' with internal linkage cannot be exported

        // using std::placeholders::_1;
        // using std::placeholders::_2;
        // using std::placeholders::_3;
        // using std::placeholders::_4;
        // using std::placeholders::_5;
        // using std::placeholders::_6;
        // using std::placeholders::_7;
        // using std::placeholders::_8;
        // using std::placeholders::_9;
        // using std::placeholders::_10;
    }

    namespace ranges
    {
        // https://libcxx.llvm.org/Status/Ranges.html

        using std::ranges::advance;
        using std::ranges::all_of;
        using std::ranges::any_of;
        using std::ranges::basic_istream_view;
        using std::ranges::begin;
        using std::ranges::bidirectional_range;
        using std::ranges::binary_transform_result;
        using std::ranges::borrowed_iterator_t;
        using std::ranges::borrowed_range;
        using std::ranges::borrowed_subrange_t;
        using std::ranges::cbegin;
        using std::ranges::cdata;
        using std::ranges::cend;
        using std::ranges::clamp;
        using std::ranges::common_range;
        using std::ranges::common_view;
        using std::ranges::construct_at;
        using std::ranges::contiguous_range;
        using std::ranges::copy;
        using std::ranges::copy_backward;
        using std::ranges::copy_backward_result;
        using std::ranges::copy_if;
        using std::ranges::copy_if_result;
        using std::ranges::copy_n;
        using std::ranges::copy_n_result;
        using std::ranges::copy_result;
        using std::ranges::count;
        using std::ranges::count_if;
        using std::ranges::crbegin;
        using std::ranges::crend;
        using std::ranges::dangling;
        using std::ranges::data;
        using std::ranges::destroy;
        using std::ranges::destroy_at;
        using std::ranges::destroy_n;
        using std::ranges::disable_sized_range;
        using std::ranges::distance;
        using std::ranges::drop_view;
        using std::ranges::drop_while_view;
        using std::ranges::elements_view;
        using std::ranges::empty;
        using std::ranges::empty_view;
        using std::ranges::enable_borrowed_range;
        using std::ranges::enable_view;
        using std::ranges::end;
        using std::ranges::equal;
        using std::ranges::equal_to;
        using std::ranges::fill;
        using std::ranges::fill_n;
        using std::ranges::filter_view;
        using std::ranges::find;
        using std::ranges::find_end;
        using std::ranges::find_first_of;
        using std::ranges::find_if;
        using std::ranges::find_if_not;
        using std::ranges::for_each;
        using std::ranges::for_each_n;
        using std::ranges::for_each_n_result;
        using std::ranges::for_each_result;
        using std::ranges::forward_range;
        using std::ranges::generate;
        using std::ranges::generate_n;
        using std::ranges::get;
        using std::ranges::greater;
        using std::ranges::greater_equal;
        using std::ranges::in_found_result;
        using std::ranges::in_fun_result;
        using std::ranges::in_in_out_result;
        using std::ranges::in_in_result;
        using std::ranges::in_out_out_result;
        using std::ranges::in_out_result;
        using std::ranges::includes;
        using std::ranges::inplace_merge;
        using std::ranges::input_range;
        using std::ranges::iota_view;
        using std::ranges::is_heap;
        using std::ranges::is_heap_until;
        using std::ranges::is_partitioned;
        using std::ranges::is_permutation;
        using std::ranges::is_sorted;
        using std::ranges::is_sorted_until;
        using std::ranges::istream_view;
        using std::ranges::iter_move;
        using std::ranges::iter_swap;
        using std::ranges::iterator_t;
        // using std::ranges::join_view;
        using std::ranges::keys_view;
        using std::ranges::lazy_split_view;
        using std::ranges::less;
        using std::ranges::less_equal;
        using std::ranges::lexicographical_compare;
        using std::ranges::make_heap;
        using std::ranges::max;
        using std::ranges::max_element;
        using std::ranges::merge;
        using std::ranges::merge_result;
        using std::ranges::min;
        using std::ranges::min_element;
        using std::ranges::min_max_result;
        using std::ranges::minmax;
        using std::ranges::minmax_element;
        using std::ranges::minmax_element_result;
        using std::ranges::minmax_result;
        using std::ranges::mismatch;
        using std::ranges::mismatch_result;
        using std::ranges::move;
        using std::ranges::move_backward;
        using std::ranges::move_backward_result;
        using std::ranges::move_result;
        using std::ranges::next;
        using std::ranges::next_permutation;
        using std::ranges::next_permutation_result;
        using std::ranges::none_of;
        using std::ranges::not_equal_to;
        using std::ranges::nth_element;
        using std::ranges::output_range;
        using std::ranges::owning_view;
        using std::ranges::partial_sort;
        using std::ranges::partial_sort_copy;
        using std::ranges::partial_sort_copy_result;
        using std::ranges::partition;
        using std::ranges::partition_copy;
        using std::ranges::partition_copy_result;
        using std::ranges::partition_point;
        using std::ranges::pop_heap;
        using std::ranges::prev;
        using std::ranges::prev_permutation;
        using std::ranges::prev_permutation_result;
        using std::ranges::push_heap;
        using std::ranges::random_access_range;
        using std::ranges::range;
        using std::ranges::range_difference_t;
        using std::ranges::range_reference_t;
        using std::ranges::range_rvalue_reference_t;
        using std::ranges::range_size_t;
        using std::ranges::range_value_t;
        using std::ranges::rbegin;
        using std::ranges::ref_view;
        using std::ranges::remove;
        using std::ranges::remove_copy;
        using std::ranges::remove_copy_if;
        using std::ranges::remove_copy_if_result;
        using std::ranges::remove_copy_result;
        using std::ranges::remove_if;
        using std::ranges::rend;
        using std::ranges::replace;
        using std::ranges::replace_copy;
        using std::ranges::replace_copy_if;
        using std::ranges::replace_copy_if_result;
        using std::ranges::replace_copy_result;
        using std::ranges::replace_if;
        using std::ranges::reverse;
        using std::ranges::reverse_copy;
        using std::ranges::reverse_copy_result;
        using std::ranges::reverse_view;
        using std::ranges::rotate;
        using std::ranges::rotate_copy;
        using std::ranges::rotate_copy_result;
        using std::ranges::sample;
        using std::ranges::search;
        using std::ranges::search_n;
        using std::ranges::sentinel_t;
        using std::ranges::set_difference;
        using std::ranges::set_difference_result;
        using std::ranges::set_intersection;
        using std::ranges::set_intersection_result;
        using std::ranges::set_symmetric_difference;
        using std::ranges::set_symmetric_difference_result;
        using std::ranges::set_union;
        using std::ranges::set_union_result;
        using std::ranges::shuffle;
        using std::ranges::single_view;
        using std::ranges::size;
        using std::ranges::sized_range;
        using std::ranges::sort;
        using std::ranges::sort_heap;
        using std::ranges::split_view;
        using std::ranges::ssize;
        using std::ranges::stable_partition;
        using std::ranges::stable_sort;
        using std::ranges::subrange;
        using std::ranges::subrange_kind;
        using std::ranges::swap;
        using std::ranges::swap_ranges;
        using std::ranges::swap_ranges_result;
        using std::ranges::take_view;
        using std::ranges::take_while_view;
        using std::ranges::transform;
        using std::ranges::transform_view;
        using std::ranges::unary_transform_result;
        using std::ranges::uninitialized_copy;
        using std::ranges::uninitialized_copy_n;
        using std::ranges::uninitialized_copy_n_result;
        using std::ranges::uninitialized_copy_result;
        using std::ranges::uninitialized_default_construct;
        using std::ranges::uninitialized_default_construct_n;
        using std::ranges::uninitialized_fill;
        using std::ranges::uninitialized_fill_n;
        using std::ranges::uninitialized_move;
        using std::ranges::uninitialized_move_n;
        using std::ranges::uninitialized_move_n_result;
        using std::ranges::uninitialized_move_result;
        using std::ranges::uninitialized_value_construct;
        using std::ranges::uninitialized_value_construct_n;
        using std::ranges::unique;
        using std::ranges::unique_copy;
        using std::ranges::unique_copy_result;
        using std::ranges::values_view;
        using std::ranges::view;
        using std::ranges::view_base;
        using std::ranges::view_interface;
        using std::ranges::viewable_range;
        using std::ranges::wistream_view;

        namespace views
        {
            using std::ranges::views::all;
            using std::ranges::views::all_t;
            using std::ranges::views::common;
            using std::ranges::views::counted;
            using std::ranges::views::drop;
            using std::ranges::views::drop_while;
            using std::ranges::views::elements;
            using std::ranges::views::empty;
            using std::ranges::views::filter;
            using std::ranges::views::iota;
            using std::ranges::views::istream;
            // using std::ranges::views::join;
            using std::ranges::views::keys;
            using std::ranges::views::lazy_split;
            using std::ranges::views::reverse;
            using std::ranges::views::single;
            using std::ranges::views::split;
            using std::ranges::views::take;
            using std::ranges::views::take_while;
            using std::ranges::views::transform;
            using std::ranges::views::values;
        }
    }

    namespace regex_constants
    {
        using std::regex_constants::awk;
        using std::regex_constants::basic;
        using std::regex_constants::collate;
        using std::regex_constants::ECMAScript;
        using std::regex_constants::egrep;
        using std::regex_constants::error_backref;
        using std::regex_constants::error_badbrace;
        using std::regex_constants::error_badrepeat;
        using std::regex_constants::error_brace;
        using std::regex_constants::error_brack;
        using std::regex_constants::error_collate;
        using std::regex_constants::error_complexity;
        using std::regex_constants::error_ctype;
        using std::regex_constants::error_escape;
        using std::regex_constants::error_paren;
        using std::regex_constants::error_range;
        using std::regex_constants::error_space;
        using std::regex_constants::error_stack;
        using std::regex_constants::error_type;
        using std::regex_constants::extended;
        using std::regex_constants::format_default;
        using std::regex_constants::format_first_only;
        using std::regex_constants::format_no_copy;
        using std::regex_constants::format_sed;
        using std::regex_constants::grep;
        using std::regex_constants::icase;
        using std::regex_constants::match_any;
        using std::regex_constants::match_continuous;
        using std::regex_constants::match_default;
        using std::regex_constants::match_flag_type;
        using std::regex_constants::match_not_bol;
        using std::regex_constants::match_not_bow;
        using std::regex_constants::match_not_eol;
        using std::regex_constants::match_not_eow;
        using std::regex_constants::match_not_null;
        using std::regex_constants::match_prev_avail;
        using std::regex_constants::multiline;
        using std::regex_constants::nosubs;
        using std::regex_constants::optimize;
        using std::regex_constants::syntax_option_type;
    }

    namespace this_thread
    {
        using std::this_thread::get_id;
        using std::this_thread::sleep_for;
        using std::this_thread::sleep_until;
    }

    namespace views = ranges::views;

#ifdef __cpp_lib_math_special_functions

// __STDCPP_WANT_MATH_SPEC_FUNCS__

    using std::assoc_laguerre;
    using std::assoc_laguerref;
    using std::assoc_laguerrel;
    using std::assoc_legendre;
    using std::assoc_legendref;
    using std::assoc_legendrel;
    using std::beta;
    using std::betaf;
    using std::betal;
    using std::comp_ellint_1;
    using std::comp_ellint_1f;
    using std::comp_ellint_1l;
    using std::comp_ellint_2;
    using std::comp_ellint_2f;
    using std::comp_ellint_2l;
    using std::comp_ellint_3;
    using std::comp_ellint_3f;
    using std::comp_ellint_3l;
    using std::cyl_bessel_i;
    using std::cyl_bessel_if;
    using std::cyl_bessel_il;
    using std::cyl_bessel_j;
    using std::cyl_bessel_jf;
    using std::cyl_bessel_jl;
    using std::cyl_bessel_k;
    using std::cyl_bessel_kf;
    using std::cyl_bessel_kl;
    using std::cyl_neumann;
    using std::cyl_neumannf;
    using std::cyl_neumannl;
    using std::ellint_1;
    using std::ellint_1f;
    using std::ellint_1l;
    using std::ellint_2;
    using std::ellint_2f;
    using std::ellint_2l;
    using std::ellint_3;
    using std::ellint_3f;
    using std::ellint_3l;
    using std::expint;
    using std::expintf;
    using std::expintl;
    using std::hermite;
    using std::hermitef;
    using std::hermitel;
    using std::legendre;
    using std::legendref;
    using std::legendrel;
    using std::laguerre;
    using std::laguerref;
    using std::laguerrel;
    using std::riemann_zeta;
    using std::riemann_zetaf;
    using std::riemann_zetal;
    using std::sph_bessel;
    using std::sph_besself;
    using std::sph_bessell;
    using std::sph_legendre;
    using std::sph_legendref;
    using std::sph_legendrel;
    using std::sph_neumann;
    using std::sph_neumannf;
    using std::sph_neumannl;

#endif

// kill from POSIX functions

    using ::kill;
    constexpr auto sigterm = SIGTERM;
    constexpr auto sigint = SIGINT;
    constexpr auto sigkill = SIGKILL;

} // namespace std

#if __cpp_lib_format < 202207L

// Let's fake utc_clock and localized formatting of some chrono types until supported by libc++

export namespace std
{

    namespace chrono
    {
        using utc_clock = std::chrono::system_clock; // FIXME
        template<typename Duration> using utc_time = std::chrono::sys_time<Duration>; // FIXME
        using utc_days = std::chrono::sys_days; // FIXME
        using utc_seconds = std::chrono::sys_seconds; // FIXME

        template<typename T, typename R>
        auto& operator << (std::ostream& os, const std::chrono::duration<T,R>& d) noexcept
        {
            os << d.count();
            return os;
        }

        template<class>
        struct is_clock : std::false_type {};
        
        template<class T>
            requires
                requires
                {
                    typename T::rep;
                    typename T::period;
                    typename T::duration;
                    typename T::time_point;
                    T::is_steady; // type is not checked
                    T::now();     // return type is not checked
                }
        struct is_clock<T> : std::true_type {};

        template< class T >
        inline constexpr bool is_clock_v = is_clock<T>::value;

    } // namesapse chrono

    template<typename Duration>
    struct formatter<chrono::utc_time<Duration>> : formatter<unsigned>
    {
        bool date = false;
        bool iso_date = false;
        bool time = false;
        bool ticks = false;

        bool year = false;
        bool month = false;
        bool day = false;

        bool hours = false;
        bool minutes = false;
        bool seconds = false;

        template <typename FormatParseContext>
        constexpr auto parse(FormatParseContext& context)
        {
            auto pos = context.begin();
            while (pos != context.end() and *pos != '}')
            {
                if(*pos == 'D') date = true;
                if(*pos == 'F') iso_date = true;
                if(*pos == 'T') time = true;
                if(*pos == 'Q') ticks = true;

                if(*pos == 'Y') year = true;
                if(*pos == 'm') month = true;
                if(*pos == 'd') day = true;

                if(*pos == 'H') hours = true;
                if(*pos == 'M') minutes = true;
                if(*pos == 'S') seconds = true;

                ++pos;
            }
            return pos;
        }

        template<typename FormatContext>
        constexpr auto format(chrono::utc_time<Duration> timestamp, FormatContext& context) const
        {
            auto out = context.out();

            if(date)
            {
                // YYYYMMDD
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto date = chrono::year_month_day{midnight};
                std::format_to(out,"{:04}{:02}{:02}",(int)date.year(),(unsigned)date.month(),(unsigned)date.day());
            }

            if(iso_date)
            {
                // YYYY-MM-DD
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto date = chrono::year_month_day{midnight};
                std::format_to(out,"{:04}-{:02}-{:02}",(int)date.year(),(unsigned)date.month(),(unsigned)date.day());
            }

            if(date and time)
                std::format_to(out,"{}",'-');

            if(time)
            {
                // HH:MM:SS.sss
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto time = chrono::hh_mm_ss{timestamp - midnight};
                const auto milliseconds = chrono::duration_cast<chrono::milliseconds>(time.subseconds());
                std::format_to(out,"{:02}:{:02}:{:02}.{:03}",time.hours().count(),time.minutes().count(),time.seconds().count(),milliseconds.count());
            }

            if(ticks)
                std::format_to(out,"{}",timestamp.time_since_epoch().count());

            if(year and month and day)
            {
                // YYYYMMDD
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto date = chrono::year_month_day{midnight};
                std::format_to(out,"{:04}{:02}{:02}",(int)date.year(),(unsigned)date.month(),(unsigned)date.day());
            }

            if(hours and minutes and seconds)
            {
                // HHMMSS
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto time = chrono::hh_mm_ss{timestamp - midnight};
                std::format_to(out,"{:02}{:02}{:02}",time.hours().count(),time.minutes().count(),time.seconds().count());
            }

            return out;
        }
    };
}

#endif

#if __cpp_lib_unreachable < 202202L

export namespace std
{
    [[noreturn]] inline void unreachable()
    {
        assert(false);
    }
}

#endif
