module;
#include <new>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <string>
#include <ratio>
#include <variant>
#include <chrono>
#include <vector>
#include <array>
#include <list>
#include <forward_list>
#include <map>
#include <set>
#include <queue>
#include <tuple>
#include <span>
#include <thread>
#include <mutex>
#include <future>
#include <condition_variable>
#include <csignal>
#include <filesystem>
#include <charconv>
#include <stdexcept>
#include <system_error>
#include <format>
#include <limits>
//#include <source_location>
#include <csignal>
export module std;

// https://libcxx.llvm.org//Status/Cxx20.html
// https://releases.llvm.org/15.0.0/projects/libcxx/docs/Status/Cxx20.html
// https://libcxx.llvm.org/Status/Format.html
// https://en.cppreference.com/w/cpp/compiler_support

export
{
    using ::operator new;
}

export namespace std
{
    using std::ios;
    using std::istream;
    using std::ostream;
    using std::ifstream;
    using std::ofstream;
    using std::stringstream;
    using std::istringstream;
    using std::ostringstream;
    using std::fstream ;

    using std::cin;
    using std::cout;
    using std::clog;
    using std::cerr;
    using std::endl;
    using std::flush;

    using std::setw;
    using std::fixed;
    using std::setprecision;
    using std::setfill;
    using std::noshowpoint;
    using std::ws;
    using std::streamoff;

    using std::string;
    using std::getline;
    using std::stoll;
    using std::string_view;
    using std::to_string;
    using std::from_chars;
    using std::from_chars_result;

    using std::vector;
    using std::array;
    using std::queue;
    using std::span;
    using std::list;
    using std::forward_list;
    using std::map;
    using std::set;
    using std::pair;

    using std::variant;
    using std::holds_alternative;
    using std::visit;

    using std::tuple;
    using std::tuple_size;
    using std::tuple_element;
    using std::uses_allocator;
    using std::tie;
    using std::get;

    using std::reverse_iterator;
    using std::make_reverse_iterator;
    using std::begin;
    using std::end;
    using std::cbegin;
    using std::cend;
    using std::rbegin;
    using std::rend;
    using std::crbegin;
    using std::crend;
    using std::advance;
    using std::distance;

    using std::thread;
    using std::future;
    using std::async;
    using std::mutex;
    using std::lock_guard;
    using std::unique_lock;
    using std::condition_variable_any;
    using std::atomic_bool;

    using std::function;
    using std::move;
    using std::forward;

    using std::max;
    using std::min;
    using std::abs;
    using std::any_of;
    using std::all_of;
    using std::rotate;
    using std::swap;

    using std::initializer_list;
    using std::index_sequence;
    using std::make_index_sequence;
    using std::reference_wrapper;
    using std::ref;

    using std::size_t;
    using std::adopt_lock_t;
    using std::try_to_lock_t;
    using std::defer_lock_t;

    using std::is_integral;
    using std::is_integral_v;
    using std::is_base_of;
    using std::is_base_of_v;
    using std::is_same;
    using std::is_same_v;

    using std::format;
    using std::formatter;
    using std::format_context;
    using std::format_parse_context;

    using std::exception;
    using std::runtime_error;
    using std::bad_variant_access;
    using std::out_of_range;
    using std::system_error;
    using std::errc;

    using std::numeric_limits;

//  using std::source_location;

// C functions

    using std::atexit;
    using std::remove;

    using std::signal;
    using std::abort;
    using std::exit;
    using std::terminate;
    using ::kill;

    constexpr auto sigterm = SIGTERM;
    constexpr auto sigint = SIGINT;
    constexpr auto sigkill = SIGKILL;

//  operators

    using std::operator <<;
    using std::operator >>;
    using std::operator +;
    using std::operator -;
    using std::operator <;
    using std::operator >;
    using std::operator <=;
    using std::operator >=;
    using std::operator ==;
    using std::operator !=;
    using std::operator <=>;

    namespace chrono
    {
        using std::chrono::system_clock;
        using std::chrono::sys_time;
        using std::chrono::sys_days;
        using std::chrono::sys_seconds;

        using utc_clock = std::chrono::system_clock; // FIXME
        template<typename Duration> using utc_time = std::chrono::sys_time<Duration>; // FIXME
        using utc_days = std::chrono::sys_days; // FIXME
        using utc_seconds = std::chrono::sys_seconds; // FIXME

        using std::chrono::duration;
        using std::chrono::time_point;
        using std::chrono::year_month_day;
        using std::chrono::hh_mm_ss;
        using std::chrono::year;
        using std::chrono::day;
        using std::chrono::month;
        using std::chrono::days;
        using std::chrono::hours;
        using std::chrono::minutes;
        using std::chrono::seconds;
        using std::chrono::milliseconds;
        using std::chrono::duration_cast;

        using std::chrono::ceil;
        using std::chrono::floor;

//      using std::chrono::operator <<; // FIXME
//      using std::chrono::operator >>; // FIXME
        using std::chrono::operator +;
        using std::chrono::operator -;
        using std::chrono::operator ==;
        using std::chrono::operator !=;
        using std::chrono::operator <;
        using std::chrono::operator >;
        using std::chrono::operator <=;
        using std::chrono::operator >=;
        using std::chrono::operator <=>;

        using std::chrono::operator /;
    }

    namespace filesystem
    {
        using std::filesystem::exists;
        using std::filesystem::remove;
    }

    namespace this_thread
    {
        using std::this_thread::sleep_for;
    }

    inline namespace string_literals
    {
        using std::string_literals::operator""s;
    }

    inline namespace string_view_literals
    {
        using std::string_view_literals::operator""sv;
    }

    inline namespace chrono_literals
    {
        using std::literals::operator""d;
        using std::literals::operator""h;
        using std::literals::operator""s;
        using std::literals::operator""us;
    }

    inline namespace literals
    {
        using std::literals::operator""sv;

        using std::literals::operator""d;
        using std::literals::operator""h;
        using std::literals::operator""s;
        using std::literals::operator""us;
    }

    template<typename Duration>
    struct formatter<chrono::utc_time<Duration>>
    {
        bool date = false;
        bool time = false;
        bool ticks = false;

        constexpr auto parse(format_parse_context& context)
        {
            auto pos = context.begin();
            while (pos != context.end() and *pos != '}')
            {
                if(*pos == 'D') date = true;
                if(*pos == 'T') time = true;
                if(*pos == 'Q') ticks = true;
                ++pos;
            }
            return pos;
        }

        template<typename FormatContext>
        constexpr auto format(const chrono::utc_time<Duration>& timestamp, FormatContext& context)
        {
            auto out = context.out();

            if(date)
            {
                // YYYYMMDD-HH:MM:SS.sss
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto date = chrono::year_month_day{midnight};
                std::format_to(out,"{:04}{:02}{:02}",(int)date.year(),(unsigned)date.month(),(unsigned)date.day());
            }

            if(date and time)
                std::format_to(out,"{}",'-');

            if(time)
            {
                // YYYYMMDD-HH:MM:SS.sss
                const auto midnight = chrono::floor<chrono::days>(timestamp);
                const auto time = chrono::hh_mm_ss{timestamp - midnight};
                const auto milliseconds = chrono::duration_cast<chrono::milliseconds>(time.subseconds());
                std::format_to(out,"{:02}:{:02}:{:02}.{:03}",time.hours().count(),time.minutes().count(),time.seconds().count(),milliseconds.count());
            }

            if(ticks)
                std::format_to(out,"{}",timestamp.time_since_epoch().count());

            return out;
        }
    };

    template <class CharT, class Traits>
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const std::chrono::year& y) noexcept
    {
        os << static_cast<int>(y);
        return os;
    }

    template <class CharT, class Traits>
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const std::chrono::month& m) noexcept
    {
        os << static_cast<unsigned>(m);
        return os;
    }

    template <class CharT, class Traits>
    std::basic_ostream<CharT, Traits>&
    operator<<(std::basic_ostream<CharT, Traits>& os, const std::chrono::day& d) noexcept
    {
        os << static_cast<unsigned>(d);
        return os;
    }

    template<typename T, typename R>
    auto& operator << (std::ostream& os, const std::chrono::duration<T,R>& d) noexcept
    {
        os << d.count();
        return os;
    }

}
