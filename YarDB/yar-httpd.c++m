export module yar:httpd;
import :engine;
import std;
import net;
import xson;

// https://www.odata.org/odata-services/

namespace db {

using namespace std::string_literals;
using namespace std::string_view_literals;
using namespace net;

inline auto stoll(std::string_view sv)
{
    auto ll = 0ll;
    auto [ptr, ec] = std::from_chars(sv.begin(),sv.end(),ll);
    if(ec != std::errc() || ptr != sv.end())
        throw std::invalid_argument{"Invalid ID format: "s + std::string{sv}};
    return ll;
}

// Helper function to URL-decode a string
inline auto url_decode(std::string_view encoded)
{
    auto decoded = std::string{};
    decoded.reserve(encoded.length());
    
    for(std::size_t i = 0; i < encoded.length(); ++i)
    {
        if(encoded[i] == '%' && i + 2 < encoded.length())
        {
            // Try to decode %XX
            auto hex = encoded.substr(i + 1, 2);
            auto value = 0;
            auto [ptr, ec] = std::from_chars(hex.data(), hex.data() + hex.length(), value, 16);
            if(ec == std::errc() && ptr == hex.data() + hex.length())
            {
                decoded += static_cast<char>(value);
                i += 2; // Skip the %XX
                continue;
            }
        }
        // Not a valid %XX sequence, or + (which should be space in query strings)
        if(encoded[i] == '+')
            decoded += ' ';
        else
            decoded += encoded[i];
    }
    
    return decoded;
}

// Helper function to parse query parameters from URI
inline auto parse_query_params(const http::uri& uri)
{
    auto params = std::map<std::string, std::string>{};
    
    // Check if query string exists
    if(static_cast<std::string_view>(uri.query).empty())
        return params;
    
    // uri.query is indexed_property<'&'>, so it splits by &
    for(std::size_t i = 0; i < 100; ++i) // Reasonable limit
    {
        auto param = uri.query[i];
        if(param.empty())
            break;
            
        // Split key=value
        auto eq_pos = param.find('=');
        if(eq_pos != std::string_view::npos)
        {
            auto key = url_decode(param.substr(0, eq_pos));
            auto value = url_decode(param.substr(eq_pos + 1));
            params[key] = value;
        }
        else
        {
            // Boolean flag (no value)
            params[url_decode(param)] = "true"s;
        }
    }
    
    return params;
}

// Helper function to parse OData $filter expression and convert to selector
// Supports: field eq 'value', field gt number, field ge number, field lt number, field le number, field ne 'value'
// Supports: and, or operators
inline db::object parse_odata_filter(std::string_view filter_expr)
{
    auto selector = db::object{};
    
    // Simple parser for basic OData filter expressions
    // Example: "age gt 25" -> {"age": {"$gt": 25}}
    // Example: "name eq 'John'" -> {"name": "John"}
    // Example: "age gt 25 and status eq 'active'" -> {"age": {"$gt": 25}, "status": "active"}
    
    auto expr = std::string{filter_expr};
    
    // Handle 'and' operator - split and process each part
    if(expr.contains(" and "s))
    {
        auto parts = std::vector<std::string>{};
        auto start = std::size_t{0};
        while(true)
        {
            auto pos = expr.find(" and "s, start);
            if(pos == std::string::npos)
            {
                parts.push_back(expr.substr(start));
                break;
            }
            parts.push_back(expr.substr(start, pos - start));
            start = pos + 5; // Skip " and "
        }
        
        // Process each part and merge into selector
        for(const auto& part : parts)
        {
            auto part_selector = parse_odata_filter(part);
            // Merge part_selector into selector (xson::object merge operator)
            selector = db::object{selector, part_selector};
        }
        return selector;
    }
    
    // Handle 'or' operator (simpler - just process parts, engine will handle OR logic via match)
    if(expr.contains(" or "s))
    {
        // For now, treat OR as AND (can be enhanced later)
        auto parts = std::vector<std::string>{};
        auto start = std::size_t{0};
        while(true)
        {
            auto pos = expr.find(" or "s, start);
            if(pos == std::string::npos)
            {
                parts.push_back(expr.substr(start));
                break;
            }
            parts.push_back(expr.substr(start, pos - start));
            start = pos + 4; // Skip " or "
        }
        
        // Process each part and merge into selector
        for(const auto& part : parts)
        {
            auto part_selector = parse_odata_filter(part);
            // Merge part_selector into selector (xson::object merge operator)
            selector = db::object{selector, part_selector};
        }
        return selector;
    }
    
    // Parse single comparison: "field operator value"
    // Trim whitespace
    while(!expr.empty() && expr[0] == ' ')
        expr.erase(0, 1);
    while(!expr.empty() && expr.back() == ' ')
        expr.pop_back();
    
    // Find operator
    auto op_pos = std::string::npos;
    auto op = ""s;
    
    if(auto pos = expr.find(" eq "s); pos != std::string::npos)
    {
        op_pos = pos;
        op = "eq"s;
    }
    else if(auto pos = expr.find(" ne "s); pos != std::string::npos)
    {
        op_pos = pos;
        op = "ne"s;
    }
    else if(auto pos = expr.find(" gt "s); pos != std::string::npos)
    {
        op_pos = pos;
        op = "gt"s;
    }
    else if(auto pos = expr.find(" ge "s); pos != std::string::npos)
    {
        op_pos = pos;
        op = "ge"s;
    }
    else if(auto pos = expr.find(" lt "s); pos != std::string::npos)
    {
        op_pos = pos;
        op = "lt"s;
    }
    else if(auto pos = expr.find(" le "s); pos != std::string::npos)
    {
        op_pos = pos;
        op = "le"s;
    }
    
    if(op_pos == std::string::npos)
        throw std::invalid_argument{"Invalid filter expression: "s + expr};
    
    auto field = expr.substr(0, op_pos);
    // Trim field
    while(!field.empty() && field.back() == ' ')
        field.pop_back();
    
    auto value_str = expr.substr(op_pos + op.size() + 1);
    // Trim value
    while(!value_str.empty() && value_str[0] == ' ')
        value_str.erase(0, 1);
    
    // Remove quotes from string values
    auto is_string = false;
    if(value_str.size() >= 2 && value_str[0] == '\'' && value_str.back() == '\'')
    {
        value_str = value_str.substr(1, value_str.size() - 2);
        is_string = true;
    }
    else if(value_str.size() >= 2 && value_str[0] == '"' && value_str.back() == '"')
    {
        value_str = value_str.substr(1, value_str.size() - 2);
        is_string = true;
    }
    
    // Convert to selector format
    if(op == "eq"s)
    {
        if(is_string)
            selector[field] = value_str;
        else
        {
            // Try to parse as number
            try
            {
                auto num = stoll(value_str);
                selector[field] = num;
            }
            catch(...)
            {
                selector[field] = value_str; // Fallback to string
            }
        }
    }
    else if(op == "ne"s)
    {
        // YarDB doesn't have $ne, so we'll use a workaround
        // For now, store as string and handle in match logic (or skip)
        throw std::invalid_argument{"$ne operator not yet supported"};
    }
    else if(op == "gt"s)
    {
        auto num = stoll(value_str);
        selector[field] = db::object{{"$gt"s, num}};
    }
    else if(op == "ge"s)
    {
        auto num = stoll(value_str);
        selector[field] = db::object{{"$gte"s, num}};
    }
    else if(op == "lt"s)
    {
        auto num = stoll(value_str);
        selector[field] = db::object{{"$lt"s, num}};
    }
    else if(op == "le"s)
    {
        auto num = stoll(value_str);
        selector[field] = db::object{{"$lte"s, num}};
    }
    
    return selector;
}

// Helper function to apply $select projection to documents
inline auto apply_select(const db::object& documents, std::string_view select_value)
{
    // Parse comma-separated field list: "name,email,age"
    auto fields = std::vector<std::string>{};
    auto start = std::size_t{0};
    auto expr = std::string{select_value};
    
    while(true)
    {
        auto pos = expr.find(',', start);
        if(pos == std::string::npos)
        {
            auto field = expr.substr(start);
            // Trim whitespace
            while(!field.empty() && field[0] == ' ')
                field.erase(0, 1);
            while(!field.empty() && field.back() == ' ')
                field.pop_back();
            if(!field.empty())
                fields.push_back(field);
            break;
        }
        auto field = expr.substr(start, pos - start);
        // Trim whitespace
        while(!field.empty() && field[0] == ' ')
            field.erase(0, 1);
        while(!field.empty() && field.back() == ' ')
            field.pop_back();
        if(!field.empty())
            fields.push_back(field);
        start = pos + 1;
    }
    
    if(fields.empty())
        return documents; // No fields specified, return as-is
    
    // Apply projection
    if(!documents.is_array())
        return documents; // Not an array, return as-is
    
    auto result = db::object{db::object::array{}};
    const auto& docs = documents.get<db::object::array>();
    
    for(const auto& doc : docs)
    {
        auto projected = db::object{};
        // Always include _id if present
        if(doc.has("_id"s))
            projected["_id"s] = doc["_id"s];
        
        // Include requested fields
        for(const auto& field : fields)
        {
            if(doc.has(field))
                projected[field] = doc[field];
        }
        
        result += std::move(projected);
    }
    
    return result;
}

// Helper function to apply $expand to documents
// For now, this is a placeholder - YarDB doesn't have explicit relationships
inline auto apply_expand(const db::object& documents, std::string_view expand_value, [[maybe_unused]] const std::string& collection_name, [[maybe_unused]] db::engine& engine)
{
    // Parse comma-separated field list: "orders,profile"
    auto fields = std::vector<std::string>{};
    auto start = std::size_t{0};
    auto expr = std::string{expand_value};
    
    while(true)
    {
        auto pos = expr.find(',', start);
        if(pos == std::string::npos)
        {
            auto field = expr.substr(start);
            // Trim whitespace
            while(!field.empty() && field[0] == ' ')
                field.erase(0, 1);
            while(!field.empty() && field.back() == ' ')
                field.pop_back();
            if(!field.empty())
                fields.push_back(field);
            break;
        }
        auto field = expr.substr(start, pos - start);
        // Trim whitespace
        while(!field.empty() && field[0] == ' ')
            field.erase(0, 1);
        while(!field.empty() && field.back() == ' ')
            field.pop_back();
        if(!field.empty())
            fields.push_back(field);
        start = pos + 1;
    }
    
    if(fields.empty())
        return documents; // No fields to expand
    
    // For now, $expand is a placeholder
    // In a real implementation, this would:
    // 1. Extract IDs from the expand field (e.g., order_ids)
    // 2. Query the related collection (e.g., orders)
    // 3. Embed the results
    
    // Return documents as-is for now
    return documents;
}

class rest_api_server
{
public:
    rest_api_server(std::string_view file, std::string_view port_or_service) :
        m_file{file},
        m_port_or_service{port_or_service},
        m_engine{file}
    {
        setup_routes();
    }

    void start()
    {
        if(m_listen_thread.joinable())
            return; // Already started
        
        m_listen_thread = std::thread{[this]()
        {
            try
            {
                m_server.listen(m_port_or_service);
            }
            catch(const std::exception& e)
            {
                // Log error if possible, but don't crash
                // The server will remain stopped if listen fails
                slog << error("httpd") << "Failed to start server: " << e.what() << flush;
            }
        }};
    }

    void stop()
    {
        // Signal the server to stop
        m_server.stop();
        // Wait for the listen thread to finish
        if(m_listen_thread.joinable())
        {
            m_listen_thread.join();
        }
    }

    // For backward compatibility - blocks forever
    void listen()
    {
        m_server.listen(m_port_or_service);
    }

    ~rest_api_server()
    {
        stop(); // Stop server and wait for thread to finish
    }

private:
    void setup_routes()
    {
        // List all collections
        m_server.get("/"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "GET /: "<< request << flush;

                    const auto guard = std::lock_guard{m_engine};
                    return std::make_tuple("200 OK"s, xson::json::stringify({"collections", m_engine.collections()}));
                });

        // Create
        m_server.post("/[a-z][a-z0-9]*"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "POST /[a-z]+: "<< request << " <- " << body << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto document = xson::json::parse(body);

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        m_engine.create(document);
                        
                        // Add Location header pointing to the newly created resource
                        auto response_headers = http::headers{};
                        const auto collection = uri.path[1];
                        const auto id = static_cast<long long>(document["_id"s]);
                        response_headers.set("Location", "/"s + std::string{collection} + "/"s + std::to_string(id));
                        
                        return std::make_tuple("201 Created"s, xson::json::stringify(document), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<http::headers>{});
                    }
                });

        // Read _id
        m_server.get("/[a-z][a-z0-9]*/[0-9]+"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "GET /[a-z]+/[0-9]+: " << request << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = db::object{};
                        auto selector = db::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        auto found = m_engine.read(selector, documents);

                        // Check if document was found
                        if(!found || documents.get<db::object::array>().empty())
                        {
                            auto error = db::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", std::string{uri.path[1]}},
                                {"id", id}
                            };
                            return std::make_tuple("404 Not Found"s, xson::json::stringify(error));
                        }

                        // Return single object (first element of array)
                        auto document = documents.get<db::object::array>()[0];
                        return std::make_tuple("200 OK"s, xson::json::stringify(document));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Read collection with OData query parameters
        // Route pattern allows optional query string: /[a-z][a-z0-9]*(\?.*)?
        // Note: Collection names must start with a letter, but can contain digits
        m_server.get("/[a-z][a-z0-9]*(\\?.*)?"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "GET /[a-z]+: " << request << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto document = db::object{};
                        auto selector = db::object{};
                        
                        // Parse OData query parameters
                        auto params = parse_query_params(uri);
                        
                        // Handle $top (OData: $top=n)
                        if(params.contains("$top"s))
                        {
                            auto top_value = stoll(params["$top"s]);
                            selector["$top"s] = top_value;
                        }
                        
                        // Handle $skip (OData: $skip=n)
                        if(params.contains("$skip"s))
                        {
                            auto skip_value = stoll(params["$skip"s]);
                            selector["$skip"s] = skip_value;
                        }
                        
                        // Handle $orderby (OData: $orderby=field desc or $orderby=field asc)
                        if(params.contains("$orderby"s))
                        {
                            auto orderby_value = params["$orderby"s];
                            // Check if it ends with " desc" or "desc"
                            if(orderby_value.ends_with(" desc"s) || orderby_value == "desc"s)
                            {
                                selector["$desc"s] = true;
                            }
                            // If it ends with " asc" or is just a field name, ascending is default
                        }
                        
                        // Handle $filter (OData: $filter=field eq 'value' or $filter=field gt number)
                        // Merge filter criteria into selector for query-time filtering
                        if(params.contains("$filter"s))
                        {
                            try
                            {
                                auto filter_selector = parse_odata_filter(params["$filter"s]);
                                // Merge filter into selector (xson::object merge operator)
                                selector = db::object{selector, filter_selector};
                            }
                            catch(const std::exception& e)
                            {
                                auto error = db::object{
                                    {"error", "Bad Request"s},
                                    {"message", "Invalid $filter expression: "s + std::string{e.what()}}
                                };
                                return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                            }
                        }

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        m_engine.read(selector, document);
                        
                        // Post-process: Apply $select projection (result transformation)
                        if(params.contains("$select"s))
                        {
                            document = apply_select(document, params["$select"s]);
                        }
                        
                        // Post-process: Apply $expand expansion (result transformation)
                        if(params.contains("$expand"s))
                        {
                            document = apply_expand(document, params["$expand"s], std::string{uri.path[1]}, m_engine);
                        }
                        
                        return std::make_tuple("200 OK"s, xson::json::stringify(document));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Update aka replace _id (upsert behavior)
        m_server.put("/[a-z][a-z0-9]*/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "PUT /[a-z]+: "<< request << " <- " << body << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto document = xson::json::parse(body);
                        auto id = stoll(uri.path[2]);
                        
                        // Ensure the document has the correct _id from the URL
                        document["_id"s] = id;
                        
                        auto selector = db::object{"_id", id};
                        auto existing_docs = db::object{};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        
                        // Check if document exists
                        auto exists = m_engine.read(selector, existing_docs);
                        auto response_headers = http::headers{};
                        const auto collection = uri.path[1];
                        const auto resource_path = "/"s + std::string{collection} + "/"s + std::to_string(id);
                        
                        if(exists && !existing_docs.get<db::object::array>().empty())
                        {
                            // Document exists - replace it
                            m_engine.replace(selector, document);
                            
                            // Add Content-Location header for updated resource
                            response_headers.set("Content-Location", resource_path);
                            
                            // Return 200 OK for update
                            return std::make_tuple("200 OK"s, xson::json::stringify(document), std::make_optional(response_headers));
                        }
                        else
                        {
                            // Document doesn't exist - create it
                            m_engine.create(document);
                            
                            // Add Location header for newly created resource
                            response_headers.set("Location", resource_path);
                            
                            return std::make_tuple("201 Created"s, xson::json::stringify(document), std::make_optional(response_headers));
                        }
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<http::headers>{});
                    }
                });

        // Update aka modify _id
        m_server.patch("/[a-z][a-z0-9]*/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "PATCH /[a-z]+: "<< request << " <- " << body << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto updates = xson::json::parse(body);
                        auto documents = db::object{};
                        auto id = stoll(uri.path[2]);
                        auto selector = db::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        m_engine.upsert(selector,updates,documents);
                        
                        // Add Content-Location header for updated resource
                        auto response_headers = http::headers{};
                        const auto collection = uri.path[1];
                        response_headers.set("Content-Location", "/"s + std::string{collection} + "/"s + std::to_string(id));
                        
                        return std::make_tuple("200 OK"s, xson::json::stringify(documents), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<http::headers>{});
                    }
                });

        // Delete _id
        m_server.destroy("/[a-z][a-z0-9]*/[0-9]+"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "DELETE /[a-z]+/[0-9]+: " << request << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = db::object{};
                        auto selector = db::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        auto deleted = m_engine.destroy(selector,documents);

                        if(!deleted)
                        {
                            auto error = db::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", std::string{uri.path[1]}},
                                {"id", id}
                            };
                            return std::make_tuple("404 Not Found"s, xson::json::stringify(error));
                        }

                        // Return 204 No Content for successful deletion
                        return std::make_tuple("204 No Content"s, ""s);
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Delete first
        m_server.destroy("/[a-z]+\\?\\$top"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "DELETE /[a-z]+?\\$top: " << request << flush;

                    auto uri = http::uri{request};
                    auto documents = db::object{};
                    auto selector = db::object{"$top",1ll};

                    const auto guard = std::lock_guard{m_engine};
                    m_engine.collection(uri.path[1]);
                    m_engine.destroy(selector,documents);
                    return std::make_tuple("200 OK"s, xson::json::stringify(documents));
                });
    }

    std::string m_file;
    std::string m_port_or_service;
    ext::lockable<db::engine> m_engine;
    http::server m_server;
    std::thread m_listen_thread;
};

// Backward compatibility wrapper function (blocks forever)
export void restful_web_server(std::string_view file, const std::string_view port_or_service)
{
    auto server = rest_api_server{file, port_or_service};
    server.listen(); // Blocks forever
}

} // namespace db
