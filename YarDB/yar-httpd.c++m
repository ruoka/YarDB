export module yar:httpd;
import :engine;
import std;
import net;
import xson;

// https://www.odata.org/odata-services/

namespace db {

using namespace std::string_literals;
using namespace std::string_view_literals;
using namespace net;

inline auto stoll(std::string_view sv)
{
    auto ll = 0ll;
    auto [ptr, ec] = std::from_chars(sv.begin(),sv.end(),ll);
    if(ec != std::errc() || ptr != sv.end())
        throw std::invalid_argument{"Invalid ID format: "s + std::string{sv}};
    return ll;
}

// Helper function to URL-decode a string
inline auto url_decode(std::string_view encoded)
{
    auto decoded = std::string{};
    decoded.reserve(encoded.length());
    
    for(std::size_t i = 0; i < encoded.length(); ++i)
    {
        if(encoded[i] == '%' && i + 2 < encoded.length())
        {
            // Try to decode %XX
            auto hex = encoded.substr(i + 1, 2);
            auto value = 0;
            auto [ptr, ec] = std::from_chars(hex.data(), hex.data() + hex.length(), value, 16);
            if(ec == std::errc() && ptr == hex.data() + hex.length())
            {
                decoded += static_cast<char>(value);
                i += 2; // Skip the %XX
                continue;
            }
        }
        // Not a valid %XX sequence, or + (which should be space in query strings)
        if(encoded[i] == '+')
            decoded += ' ';
        else
            decoded += encoded[i];
    }
    
    return decoded;
}

// Helper function to parse query parameters from URI
inline auto parse_query_params(const http::uri& uri)
{
    auto params = std::map<std::string, std::string>{};
    
    // Check if query string exists
    if(static_cast<std::string_view>(uri.query).empty())
        return params;
    
    // uri.query is indexed_property<'&'>, so it splits by &
    for(std::size_t i = 0; i < 100; ++i) // Reasonable limit
    {
        auto param = uri.query[i];
        if(param.empty())
            break;
            
        // Split key=value
        auto eq_pos = param.find('=');
        if(eq_pos != std::string_view::npos)
        {
            auto key = url_decode(param.substr(0, eq_pos));
            auto value = url_decode(param.substr(eq_pos + 1));
            params[key] = value;
        }
        else
        {
            // Boolean flag (no value)
            params[url_decode(param)] = "true"s;
        }
    }
    
    return params;
}

class rest_api_server
{
public:
    rest_api_server(std::string_view file, std::string_view port_or_service) :
        m_file{file},
        m_port_or_service{port_or_service},
        m_engine{file}
    {
        setup_routes();
    }

    void start()
    {
        if(m_listen_thread.joinable())
            return; // Already started
        
        m_listen_thread = std::thread{[this]()
        {
            try
            {
                m_server.listen(m_port_or_service);
            }
            catch(const std::exception& e)
            {
                // Log error if possible, but don't crash
                // The server will remain stopped if listen fails
                slog << error("httpd") << "Failed to start server: " << e.what() << flush;
            }
        }};
    }

    void stop()
    {
        // Signal the server to stop
        m_server.stop();
        // Wait for the listen thread to finish
        if(m_listen_thread.joinable())
        {
            m_listen_thread.join();
        }
    }

    // For backward compatibility - blocks forever
    void listen()
    {
        m_server.listen(m_port_or_service);
    }

    ~rest_api_server()
    {
        stop(); // Stop server and wait for thread to finish
    }

private:
    void setup_routes()
    {
        // List all collections
        m_server.get("/"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "GET /: "<< request << flush;

                    const auto guard = std::lock_guard{m_engine};
                    return std::make_tuple("200 OK"s, xson::json::stringify({"collections", m_engine.collections()}));
                });

        // Create
        m_server.post("/[a-z]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "POST /[a-z]+: "<< request << " <- " << body << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto document = xson::json::parse(body);

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        m_engine.create(document);
                        
                        // Add Location header pointing to the newly created resource
                        auto response_headers = http::headers{};
                        const auto collection = uri.path[1];
                        const auto id = static_cast<long long>(document["_id"s]);
                        response_headers.set("Location", "/"s + std::string{collection} + "/"s + std::to_string(id));
                        
                        return std::make_tuple("201 Created"s, xson::json::stringify(document), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<http::headers>{});
                    }
                });

        // Read _id
        m_server.get("/[a-z]+/[0-9]+"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "GET /[a-z]+/[0-9]+: " << request << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = db::object{};
                        auto selector = db::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        auto found = m_engine.read(selector, documents);

                        // Check if document was found
                        if(!found || documents.get<db::object::array>().empty())
                        {
                            auto error = db::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", std::string{uri.path[1]}},
                                {"id", id}
                            };
                            return std::make_tuple("404 Not Found"s, xson::json::stringify(error));
                        }

                        // Return single object (first element of array)
                        auto document = documents.get<db::object::array>()[0];
                        return std::make_tuple("200 OK"s, xson::json::stringify(document));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Read collection with OData query parameters
        // Route pattern allows optional query string: /[a-z]+(\?.*)?
        m_server.get("/[a-z]+(\\?.*)?"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "GET /[a-z]+: " << request << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto document = db::object{};
                        auto selector = db::object{};
                        
                        // Parse OData query parameters
                        auto params = parse_query_params(uri);
                        
                        // Handle $top (OData: $top=n)
                        if(params.contains("$top"s))
                        {
                            auto top_value = stoll(params["$top"s]);
                            selector["$top"s] = top_value;
                        }
                        
                        // Handle $skip (OData: $skip=n)
                        if(params.contains("$skip"s))
                        {
                            // Note: $skip is not yet supported by engine, but we parse it for OData compliance
                            // For now, we'll ignore it (engine doesn't support skip)
                            slog << debug << "GET /[a-z]+: $skip parameter parsed but not yet implemented in engine" << flush;
                        }
                        
                        // Handle $orderby (OData: $orderby=field desc or $orderby=field asc)
                        if(params.contains("$orderby"s))
                        {
                            auto orderby_value = params["$orderby"s];
                            // Check if it ends with " desc" or "desc"
                            if(orderby_value.ends_with(" desc"s) || orderby_value == "desc"s)
                            {
                                selector["$desc"s] = true;
                            }
                            // If it ends with " asc" or is just a field name, ascending is default
                        }

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        m_engine.read(selector, document);
                        return std::make_tuple("200 OK"s, xson::json::stringify(document));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Update aka replace _id (upsert behavior)
        m_server.put("/[a-z]+/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "PUT /[a-z]+: "<< request << " <- " << body << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto document = xson::json::parse(body);
                        auto id = stoll(uri.path[2]);
                        
                        // Ensure the document has the correct _id from the URL
                        document["_id"s] = id;
                        
                        auto selector = db::object{"_id", id};
                        auto existing_docs = db::object{};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        
                        // Check if document exists
                        auto exists = m_engine.read(selector, existing_docs);
                        auto response_headers = http::headers{};
                        const auto collection = uri.path[1];
                        const auto resource_path = "/"s + std::string{collection} + "/"s + std::to_string(id);
                        
                        if(exists && !existing_docs.get<db::object::array>().empty())
                        {
                            // Document exists - replace it
                            m_engine.replace(selector, document);
                            
                            // Add Content-Location header for updated resource
                            response_headers.set("Content-Location", resource_path);
                            
                            // Return 200 OK for update
                            return std::make_tuple("200 OK"s, xson::json::stringify(document), std::make_optional(response_headers));
                        }
                        else
                        {
                            // Document doesn't exist - create it
                            m_engine.create(document);
                            
                            // Add Location header for newly created resource
                            response_headers.set("Location", resource_path);
                            
                            return std::make_tuple("201 Created"s, xson::json::stringify(document), std::make_optional(response_headers));
                        }
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<http::headers>{});
                    }
                });

        // Update aka modify _id
        m_server.patch("/[a-z]+/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "PATCH /[a-z]+: "<< request << " <- " << body << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto updates = xson::json::parse(body);
                        auto documents = db::object{};
                        auto id = stoll(uri.path[2]);
                        auto selector = db::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        m_engine.upsert(selector,updates,documents);
                        
                        // Add Content-Location header for updated resource
                        auto response_headers = http::headers{};
                        const auto collection = uri.path[1];
                        response_headers.set("Content-Location", "/"s + std::string{collection} + "/"s + std::to_string(id));
                        
                        return std::make_tuple("200 OK"s, xson::json::stringify(documents), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<http::headers>{});
                    }
                });

        // Delete _id
        m_server.destroy("/[a-z]+/[0-9]+"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "DELETE /[a-z]+/[0-9]+: " << request << flush;

                    try
                    {
                        auto uri = http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = db::object{};
                        auto selector = db::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        m_engine.collection(uri.path[1]);
                        auto deleted = m_engine.destroy(selector,documents);

                        if(!deleted)
                        {
                            auto error = db::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", std::string{uri.path[1]}},
                                {"id", id}
                            };
                            return std::make_tuple("404 Not Found"s, xson::json::stringify(error));
                        }

                        // Return 204 No Content for successful deletion
                        return std::make_tuple("204 No Content"s, ""s);
                    }
                    catch(const std::exception& e)
                    {
                        auto error = db::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Delete first
        m_server.destroy("/[a-z]+\\?\\$top"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const http::headers& headers)
                {
                    slog << debug << "DELETE /[a-z]+?\\$top: " << request << flush;

                    auto uri = http::uri{request};
                    auto documents = db::object{};
                    auto selector = db::object{"$top",1ll};

                    const auto guard = std::lock_guard{m_engine};
                    m_engine.collection(uri.path[1]);
                    m_engine.destroy(selector,documents);
                    return std::make_tuple("200 OK"s, xson::json::stringify(documents));
                });
    }

    std::string m_file;
    std::string m_port_or_service;
    ext::lockable<db::engine> m_engine;
    http::server m_server;
    std::thread m_listen_thread;
};

// Backward compatibility wrapper function (blocks forever)
export void restful_web_server(std::string_view file, const std::string_view port_or_service)
{
    auto server = rest_api_server{file, port_or_service};
    server.listen(); // Blocks forever
}

} // namespace db
