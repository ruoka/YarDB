export module yar:index;
import std;
import xson;

using namespace std::string_literals;

namespace db {

using object = xson::object;

using sequence_type = xson::integer_type;

using primary_key_type = sequence_type;

using secondary_index_name = std::string;

using secondary_key_type = std::string;

using position_type = std::streamoff;

using primary_index_type = std::map<primary_key_type,
                                    position_type>;

using secondary_index_type = std::map<secondary_key_type,
                                      position_type>;

using secondary_index_map = std::map<secondary_index_name,
                                     secondary_index_type>;

class index_iterator
{
public:

    enum index_type {primary, secondary, reverse_primary, reverse_secondary};

    using primary_iterator = primary_index_type::const_iterator;

    using secondary_iterator = secondary_index_type::const_iterator;

    using reverse_primary_iterator = std::reverse_iterator<primary_iterator>;

    using reverse_secondary_iterator = std::reverse_iterator<secondary_iterator>;

    index_iterator() = delete;

    index_iterator(const index_iterator&) = default;

    index_iterator& operator = (const index_iterator&) = delete;

    index_iterator(primary_iterator current) :
        m_primary_current{current},
        m_secondary_current{},
        m_reverse_primary_current{},
        m_reverse_secondary_current{},
        c_index_type{primary}
    {}

    index_iterator(secondary_iterator current) :
        m_primary_current{},
        m_secondary_current{current},
        m_reverse_primary_current{},
        m_reverse_secondary_current{},
        c_index_type{secondary}
    {}

    index_iterator(reverse_primary_iterator current) :
        m_primary_current{},
        m_secondary_current{},
        m_reverse_primary_current{current},
        m_reverse_secondary_current{},
        c_index_type{reverse_primary}
    {}

    index_iterator(reverse_secondary_iterator current) :
        m_primary_current{},
        m_secondary_current{},
        m_reverse_primary_current{},
        m_reverse_secondary_current{current},
        c_index_type{reverse_secondary}
    {}

    auto operator * ()
    {
        switch(c_index_type)
        {
        case primary:
            return std::get<position_type>(*m_primary_current);
        case secondary:
            return std::get<position_type>(*m_secondary_current);
        case reverse_primary:
            return std::get<position_type>(*m_reverse_primary_current);
        case reverse_secondary:
            return std::get<position_type>(*m_reverse_secondary_current);
        }
        std::unreachable();
    }

    auto& operator ++ ()
    {
        switch(c_index_type)
        {
        case primary:
            ++m_primary_current;
            break;
        case secondary:
            ++m_secondary_current;
            break;
        case reverse_primary:
            ++m_reverse_primary_current;
            break;
        case reverse_secondary:
            ++m_reverse_secondary_current;
            break;
        }
        return *this;
    }

    auto operator != (const index_iterator& itr) const
    {
        switch(c_index_type)
        {
        case primary:
            return m_primary_current != itr.m_primary_current;
        case secondary:
            return m_secondary_current != itr.m_secondary_current;
        case reverse_primary:
            return m_reverse_primary_current != itr.m_reverse_primary_current;
        case reverse_secondary:
            return m_reverse_secondary_current != itr.m_reverse_secondary_current;
        }
        std::unreachable();
    }

private:

    primary_iterator m_primary_current;

    secondary_iterator m_secondary_current;

    reverse_primary_iterator m_reverse_primary_current;

    reverse_secondary_iterator m_reverse_secondary_current;

    const index_type c_index_type;
};

class index_view : public std::ranges::view_interface<index_view>
{
public:

    template<typename T>
    index_view(T begin, T end) :
        m_begin{begin},
        m_end{end}
    {}

    auto begin() const
    {
        return m_begin;
    }

    auto end() const
    {
        return m_end;
    }

private:

    index_iterator m_begin, m_end;
};

// Index for fast document lookup by primary key (_id) and secondary keys
// Maintains primary index (by _id) and secondary indexes (by user-defined fields)
class index
{
public:

    index() = default;

    // Add a single secondary index key
    // @param key Field name to index
    void add(const std::string& key);

    // Add multiple secondary index keys
    // @param keys Vector of field names to index
    void add(std::vector<std::string> keys);

    // Get list of all secondary index key names
    // @return Vector of secondary key names
    std::vector<std::string> keys() const;

    // Check if selector uses primary key (_id)
    // @param selector Query selector
    // @return true if selector contains _id field
    bool primary_key(const xson::object& selector) const;

    // Check if selector uses any secondary key
    // @param selector Query selector
    // @return true if selector contains any indexed secondary key field
    bool secondary_key(const xson::object& selector) const;

    // Get index view for querying documents by selector
    // Returns iterator over positions matching the selector
    // @param selector Query selector (can use primary or secondary keys)
    // @return Index view providing iterator over matching document positions
    index_view view(const xson::object& selector) const;

    // Update document and assign _id if missing
    // Increments sequence counter for new _id assignment
    // @param document Document to update (may be modified to add _id)
    void update(xson::object& document);

    // Insert document into index with storage position
    // Updates primary key index and all matching secondary key indexes
    // Overwrites existing entries if document with same key already exists
    // @param document Document to index
    // @param position Storage file position where document is stored
    void insert(xson::object& document, position_type position);

    // Erase document from all indexes
    // Removes from primary key index and all secondary key indexes
    // @param document Document to remove from index
    void erase(const xson::object& document);

private:

    xson::integer_type  m_sequence;

    std::map<xson::integer_type, position_type> m_primary_keys;

    secondary_index_map m_secondary_keys;
};

} // namespace db
