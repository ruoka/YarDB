export module yar:httpd;
import :engine;
import :constants;
import :helper;
import :odata;
import std;
import net;
import xson;

// https://www.odata.org/odata-services/

namespace yar::http {

using namespace std::string_literals;
using namespace std::string_view_literals;
using namespace net;
using namespace yar::http::helpers;
using namespace yar::http::odata;

class rest_api_server
{
public:
    rest_api_server(std::string_view file, std::string_view port_or_service) :
        m_file{file},
        m_port_or_service{port_or_service},
        m_engine{file}
    {
        setup_routes();
    }

    void start()
    {
        if(m_listen_thread.joinable())
            return; // Already started
        
        m_listen_thread = std::thread{[this]()
        {
            try
            {
                m_server.listen(m_port_or_service);
            }
            catch(const std::exception& e)
            {
                // Log error if possible, but don't crash
                // The server will remain stopped if listen fails
                slog << error("httpd") << "Failed to start server: " << e.what() << flush;
            }
        }};
    }

    void stop()
    {
        // Signal the server to stop
        m_server.stop();
        // Wait for the listen thread to finish
        if(m_listen_thread.joinable())
        {
            m_listen_thread.join();
        }
    }

    // For backward compatibility - blocks forever
    void listen()
    {
        m_server.listen(m_port_or_service);
    }

    ~rest_api_server()
    {
        stop(); // Stop server and wait for thread to finish
    }

private:
    void setup_routes()
    {

        // Create
        m_server.post("/[a-z][a-z0-9]*"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "POST /[a-z]+: "<< request << " <- " << body << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                    {
                        auto error = xson::object{
                            {"error", "Not Acceptable"s},
                            {"message", "Only application/json is supported"s}
                        };
                        return std::make_tuple("406 Not Acceptable"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto document = xson::json::parse(body);

                        const auto guard = std::lock_guard{m_engine};
                        auto collection = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection);
                        m_engine.create(document);
                        
                        // Add Location header pointing to the newly created resource
                        auto response_headers = ::http::headers{};
                        const auto id = static_cast<long long>(document["_id"s]);
                        response_headers.set("location"s, "/"s + collection + "/"s + std::to_string(id));
                        
                        // Add OData metadata if requested
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                            document = yar::http::odata::add_metadata(document, metadata_level, collection, id);
                        
                        return std::make_tuple("201 Created"s, xson::json::stringify(document), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }
                });

        // Read _id
        m_server.get("/[a-z][a-z0-9]*/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "GET /[a-z]+/[0-9]+: " << request << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                        return not_acceptable_response_with_headers();

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = xson::object{};
                        auto selector = xson::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        auto collection = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection);
                        auto found = m_engine.read(selector, documents);

                        // Check if document was found
                        if(!found || documents.get<xson::object::array>().empty())
                        {
                            auto error = xson::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", collection},
                                {"id", id}
                            };
                            return std::make_tuple("404 Not Found"s, xson::json::stringify(error), std::optional<::http::headers>{});
                        }

                        // Return single object (first element of array)
                        auto document = documents.get<xson::object::array>()[0];
                        
                        // Add OData metadata if requested
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                            document = yar::http::odata::add_metadata(document, metadata_level, collection, id);
                        
                        // Get actual document modification time and position from metadata
                        auto response_headers = ::http::headers{};
                        auto metadata_timestamp = m_engine.get_metadata_timestamp(selector);
                        auto metadata_position = m_engine.get_metadata_position(selector);
                        
                        // Generate ETag from position
                        if(metadata_position.has_value())
                        {
                            auto etag = generate_etag(metadata_position.value());
                            response_headers.set("etag"s, etag);
                            
                            // Check If-None-Match conditional request (for GET/HEAD)
                            auto none_match_check = check_if_none_match(headers, etag);
                            if(none_match_check.has_value() && !none_match_check.value())
                            {
                                // ETag matches - resource not modified, return 304 Not Modified
                                if(metadata_timestamp.has_value())
                                {
                                    auto last_modified = format_http_date(metadata_timestamp.value());
                                    response_headers.set("last-modified"s, last_modified);
                                }
                                return std::make_tuple("304 Not Modified"s, ""s, std::make_optional(response_headers));
                            }
                        }
                        
                        if(metadata_timestamp.has_value())
                        {
                            auto last_modified = format_http_date(metadata_timestamp.value());
                            response_headers.set("last-modified"s, last_modified);
                            
                            // Check If-Modified-Since conditional request
                            auto modified_check = check_if_modified_since(headers, metadata_timestamp.value());
                            if(modified_check.has_value() && !modified_check.value())
                            {
                                // Document not modified since client's date - return 304 Not Modified
                                return std::make_tuple("304 Not Modified"s, ""s, std::make_optional(response_headers));
                            }
                        }
                        
                        return std::make_tuple("200 OK"s, xson::json::stringify(document), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }
                });

        // Read collection with OData query parameters
        // Route pattern allows optional query string: /[a-z][a-z0-9]*(\?.*)?
        // Note: Collection names must start with a letter, but can contain digits
        m_server.get("/[a-z][a-z0-9]*(\\?.*)?"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "GET /[a-z]+: " << request << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                        return not_acceptable_response();

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto document = xson::object{};
                        auto selector = xson::object{};
                        
                        // Parse OData query parameters
                        auto params = parse_query_params(uri);
                        
                        // Handle $count (OData: $count=true) - return count only
                        if(params.contains("$count"s) && params["$count"s] == "true"s)
                        {
                            // Build selector for counting (without $top/$skip to get full count)
                            auto count_selector = xson::object{};
                            
                            // Handle $filter for counting
                            auto string_filters = std::vector<string_filter>{};
                            if(params.contains("$filter"s))
                            {
                                try
                                {
                                    auto [filter_selector, filter_string_filters] = yar::http::odata::parse_filter(params["$filter"s]);
                                    // Merge filter into selector
                                    for(const auto& [key, value] : filter_selector.get<xson::object::map>())
                                    {
                                        count_selector[key] = value;
                                    }
                                    // Collect string filters for post-processing
                                    string_filters = std::move(filter_string_filters);
                                }
                                catch(const std::exception& e)
                                {
                                    auto error = xson::object{
                                        {"error", "Bad Request"s},
                                        {"message", "Invalid $filter expression: "s + std::string{e.what()}}
                                    };
                                    return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                                }
                            }
                            
                            const auto guard = std::lock_guard{m_engine};
                            auto collection_name = validate_collection_name(uri.path[1]);
                            m_engine.collection(collection_name);
                            
                            // Read all matching documents to count them
                            auto documents = xson::object{};
                            m_engine.read(count_selector, documents);
                            
                            // Apply string filters if any
                            if(!string_filters.empty())
                            {
                                documents = yar::http::odata::apply_string_filters(documents, string_filters);
                            }
                            
                            // Count the documents
                            auto count = 0ll;
                            if(documents.is_array())
                            {
                                count = static_cast<long long>(documents.get<xson::object::array>().size());
                            }
                            
                            // Return count as JSON number (OData spec: $count=true returns just the number)
                            // JSON numbers are valid as plain strings (e.g., "42" is valid JSON)
                            return std::make_tuple("200 OK"s, std::to_string(count));
                        }

                        // Handle $top (OData: $top=n)
                        if(params.contains("$top"s))
                        {
                            try
                            {
                                auto top_value = stoll(params["$top"s]);
                                if(top_value < 0)
                                    throw std::invalid_argument{"$top must be non-negative"};
                                if(top_value > yar::db::max_query_top)
                                    throw std::invalid_argument{"$top exceeds maximum ("s + std::to_string(yar::db::max_query_top) + ")"};
                                selector["$top"s] = top_value;
                            }
                            catch(const std::exception&)
                            {
                                throw std::invalid_argument{"$top must be a valid integer"};
                            }
                        }
                        
                        // Handle $skip (OData: $skip=n)
                        if(params.contains("$skip"s))
                        {
                            try
                            {
                                auto skip_value = stoll(params["$skip"s]);
                                if(skip_value < 0)
                                    throw std::invalid_argument{"$skip must be non-negative"};
                                if(skip_value > yar::db::max_query_skip)
                                    throw std::invalid_argument{"$skip exceeds maximum ("s + std::to_string(yar::db::max_query_skip) + ")"};
                                selector["$skip"s] = skip_value;
                            }
                            catch(const std::exception&)
                            {
                                throw std::invalid_argument{"$skip must be a valid integer"};
                            }
                        }
                        
                        // Handle $orderby (OData: $orderby=field desc or $orderby=field asc)
                        if(params.contains("$orderby"s))
                        {
                            const auto orderby_value = params["$orderby"s];
                            auto orderby = trim(std::string_view{orderby_value});
                            
                            // Extract field name (remove " desc" or " asc" suffix if present)
                            auto field_name = orderby;
                            if(orderby.ends_with(" desc"sv))
                                field_name = trim(orderby.substr(0, orderby.size() - 5));
                            else if(orderby.ends_with(" asc"sv))
                                field_name = trim(orderby.substr(0, orderby.size() - 4));
                            
                            // Validate field name
                            if(field_name.empty())
                                throw std::invalid_argument{"$orderby field name cannot be empty"};
                            
                            if(field_name.size() > yar::db::max_field_name_length)
                                throw std::invalid_argument{"$orderby field name too long (max "s + std::to_string(yar::db::max_field_name_length) + " chars)"};
                            
                            // Store field name for ordering
                            selector["$orderby"s] = std::string{field_name};
                            
                            // Check if it ends with " desc" or is just "desc"
                            if(orderby.ends_with(" desc"sv) || orderby == "desc"sv)
                            {
                                selector["$desc"s] = true;
                            }
                            // If it ends with " asc" or is just a field name, ascending is default
                        }
                        
                        // Handle $filter (OData: $filter=field eq 'value' or $filter=field gt number)
                        // Merge filter criteria into selector for query-time filtering
                        auto string_filters = std::vector<string_filter>{};
                        if(params.contains("$filter"s))
                        {
                            try
                            {
                                auto [filter_selector, filter_string_filters] = yar::http::odata::parse_filter(params["$filter"s]);
                                // Merge filter into selector by copying fields
                                for(const auto& [key, value] : filter_selector.get<xson::object::map>())
                                {
                                    selector[key] = value;
                                }
                                // Collect string filters for post-processing
                                string_filters = std::move(filter_string_filters);
                            }
                            catch(const std::exception& e)
                            {
                                auto error = xson::object{
                                    {"error", "Bad Request"s},
                                    {"message", "Invalid $filter expression: "s + std::string{e.what()}}
                                };
                                return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                            }
                        }

                        const auto guard = std::lock_guard{m_engine};
                        auto collection_name = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection_name);
                        m_engine.read(selector, document);
                        
                        // Post-process: Apply string filters (startswith, contains, endswith)
                        if(!string_filters.empty())
                        {
                            document = yar::http::odata::apply_string_filters(document, string_filters);
                        }
                        
                        // Post-process: Apply $select projection (result transformation)
                        if(params.contains("$select"s))
                        {
                            document = yar::http::odata::apply_select(document, params["$select"s]);
                        }
                        
                        // Post-process: Apply $expand expansion (result transformation)
                        if(params.contains("$expand"s))
                        {
                            document = yar::http::odata::apply_expand(document, params["$expand"s], collection_name, m_engine);
                        }
                        
                        // Add OData metadata if requested
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                        {
                            if(document.is_array())
                            {
                                document = yar::http::odata::add_metadata_to_array(document, metadata_level, collection_name);
                            }
                            else if(document.has("_id"s))
                            {
                                // Single object - add metadata directly
                                auto doc_id = static_cast<long long>(document["_id"s]);
                                document = yar::http::odata::add_metadata(document, metadata_level, collection_name, doc_id);
                            }
                        }
                        
                        return std::make_tuple("200 OK"s, xson::json::stringify(document));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // HEAD / - List all collections (same as GET but no body)
        m_server.head("/"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "HEAD /: "<< request << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                        return not_acceptable_response();

                    // Compute response content for correct Content-Length header (framework won't send body for HEAD)
                    const auto guard = std::lock_guard{m_engine};
                    auto response = xson::object{"collections", m_engine.collections()};
                    
                    // Add OData metadata if requested
                    auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                    if(metadata_level != yar::http::odata::metadata_level::none)
                    {
                        response["@odata.context"s] = "/$metadata#Collections"s;
                    }
                    
                    const auto content = xson::json::stringify(response);
                    return std::make_tuple("200 OK"s, content);
                });

        // HEAD /collection/{id} - Get document headers (same as GET but no body)
        m_server.head("/[a-z][a-z0-9]*/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "HEAD /[a-z]+/[0-9]+: " << request << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                        return not_acceptable_response_with_headers();

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = xson::object{};
                        auto selector = xson::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        auto collection = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection);
                        auto found = m_engine.read(selector, documents);

                        // Check if document was found
                        if(!found || documents.get<xson::object::array>().empty())
                        {
                            auto error = xson::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", collection},
                                {"id", id}
                            };
                            const auto error_content = xson::json::stringify(error);
                            return std::make_tuple("404 Not Found"s, error_content, std::optional<::http::headers>{});
                        }

                        // Compute response content for correct Content-Length header (framework won't send body for HEAD)
                        auto document = documents.get<xson::object::array>()[0];
                        
                        // Add OData metadata if requested
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                            document = yar::http::odata::add_metadata(document, metadata_level, collection, id);
                        
                        // Get actual document modification time and position from metadata
                        auto response_headers = ::http::headers{};
                        auto metadata_timestamp = m_engine.get_metadata_timestamp(selector);
                        auto metadata_position = m_engine.get_metadata_position(selector);
                        
                        // Generate ETag from position
                        if(metadata_position.has_value())
                        {
                            auto etag = generate_etag(metadata_position.value());
                            response_headers.set("etag"s, etag);
                            
                            // Check If-None-Match conditional request (for GET/HEAD)
                            auto none_match_check = check_if_none_match(headers, etag);
                            if(none_match_check.has_value() && !none_match_check.value())
                            {
                                // ETag matches - resource not modified, return 304 Not Modified
                                if(metadata_timestamp.has_value())
                                {
                                    auto last_modified = format_http_date(metadata_timestamp.value());
                                    response_headers.set("last-modified"s, last_modified);
                                }
                                const auto content = xson::json::stringify(document); // Still compute for Content-Length
                                return std::make_tuple("304 Not Modified"s, ""s, std::make_optional(response_headers));
                            }
                        }
                        
                        if(metadata_timestamp.has_value())
                        {
                            auto last_modified = format_http_date(metadata_timestamp.value());
                            response_headers.set("last-modified"s, last_modified);
                            
                            // Check If-Modified-Since conditional request
                            auto modified_check = check_if_modified_since(headers, metadata_timestamp.value());
                            if(modified_check.has_value() && !modified_check.value())
                            {
                                // Document not modified since client's date - return 304 Not Modified
                                const auto content = xson::json::stringify(document); // Still compute for Content-Length
                                return std::make_tuple("304 Not Modified"s, ""s, std::make_optional(response_headers));
                            }
                        }
                        
                        const auto content = xson::json::stringify(document);
                        return std::make_tuple("200 OK"s, content, std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }
                });

        // HEAD /collection - Get collection headers (same as GET but no body)
        // Note: We compute the full response to get correct Content-Length header
        // Framework will use content.length() for Content-Length but won't send body for HEAD
        m_server.head("/[a-z][a-z0-9]*(\\?.*)?"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "HEAD /[a-z]+: " << request << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                        return not_acceptable_response();

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto document = xson::object{};
                        auto selector = xson::object{};
                        
                        // Parse OData query parameters (same as GET)
                        auto params = parse_query_params(uri);
                        
                        // Handle $top, $skip, $orderby, $filter, $select, $expand (same as GET)
                        // This is needed to compute correct Content-Length header
                        if(params.contains("$top"s))
                        {
                            try
                            {
                                auto top_value = stoll(params["$top"s]);
                                if(top_value < 0)
                                    throw std::invalid_argument{"$top must be non-negative"};
                                if(top_value > yar::db::max_query_top)
                                    throw std::invalid_argument{"$top exceeds maximum ("s + std::to_string(yar::db::max_query_top) + ")"};
                                selector["$top"s] = top_value;
                            }
                            catch(const std::exception&)
                            {
                                throw std::invalid_argument{"$top must be a valid integer"};
                            }
                        }
                        
                        if(params.contains("$skip"s))
                        {
                            try
                            {
                                auto skip_value = stoll(params["$skip"s]);
                                if(skip_value < 0)
                                    throw std::invalid_argument{"$skip must be non-negative"};
                                if(skip_value > yar::db::max_query_skip)
                                    throw std::invalid_argument{"$skip exceeds maximum ("s + std::to_string(yar::db::max_query_skip) + ")"};
                                selector["$skip"s] = skip_value;
                            }
                            catch(const std::exception&)
                            {
                                throw std::invalid_argument{"$skip must be a valid integer"};
                            }
                        }
                        
                        if(params.contains("$orderby"s))
                        {
                            const auto orderby_value = params["$orderby"s];
                            auto orderby = trim(std::string_view{orderby_value});
                            auto field_name = orderby;
                            if(orderby.ends_with(" desc"sv))
                                field_name = trim(orderby.substr(0, orderby.size() - 5));
                            else if(orderby.ends_with(" asc"sv))
                                field_name = trim(orderby.substr(0, orderby.size() - 4));
                            if(field_name.empty())
                                throw std::invalid_argument{"$orderby field name cannot be empty"};
                            constexpr auto max_field_name_length = 256;
                            if(field_name.size() > max_field_name_length)
                                throw std::invalid_argument{"$orderby field name too long (max "s + std::to_string(max_field_name_length) + " chars)"};
                            selector["$orderby"s] = std::string{field_name};
                            if(orderby.ends_with(" desc"sv) || orderby == "desc"sv)
                                selector["$desc"s] = true;
                        }
                        
                        auto string_filters = std::vector<string_filter>{};
                        if(params.contains("$filter"s))
                        {
                            try
                            {
                                auto [filter_selector, filter_string_filters] = yar::http::odata::parse_filter(params["$filter"s]);
                                for(const auto& [key, value] : filter_selector.get<xson::object::map>())
                                    selector[key] = value;
                                string_filters = std::move(filter_string_filters);
                            }
                            catch(const std::exception& e)
                            {
                                auto error = xson::object{
                                    {"error", "Bad Request"s},
                                    {"message", "Invalid $filter expression: "s + std::string{e.what()}}
                                };
                                return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                            }
                        }

                        const auto guard = std::lock_guard{m_engine};
                        auto collection_name = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection_name);
                        m_engine.read(selector, document);
                        
                        // Post-process: Apply string filters, $select, $expand (same as GET)
                        if(!string_filters.empty())
                            document = yar::http::odata::apply_string_filters(document, string_filters);
                        if(params.contains("$select"s))
                            document = yar::http::odata::apply_select(document, params["$select"s]);
                        if(params.contains("$expand"s))
                            document = yar::http::odata::apply_expand(document, params["$expand"s], collection_name, m_engine);
                        
                        // Add OData metadata if requested (same as GET)
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                        {
                            if(document.is_array())
                            {
                                document = yar::http::odata::add_metadata_to_array(document, metadata_level, collection_name);
                            }
                            else if(document.has("_id"s))
                            {
                                // Single object - add metadata directly
                                auto doc_id = static_cast<long long>(document["_id"s]);
                                document = yar::http::odata::add_metadata(document, metadata_level, collection_name, doc_id);
                            }
                        }
                        
                        // Compute response content for correct Content-Length header (framework won't send body for HEAD)
                        const auto content = xson::json::stringify(document);
                        return std::make_tuple("200 OK"s, content);
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Update aka replace _id (upsert behavior)
        m_server.put("/[a-z][a-z0-9]*/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "PUT /[a-z]+: "<< request << " <- " << body << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                    {
                        auto error = xson::object{
                            {"error", "Not Acceptable"s},
                            {"message", "Only application/json is supported"s}
                        };
                        return std::make_tuple("406 Not Acceptable"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto document = xson::json::parse(body);
                        auto id = stoll(uri.path[2]);
                        
                        // Ensure the document has the correct _id from the URL
                        document["_id"s] = id;
                        
                        auto selector = xson::object{"_id", id};
                        auto existing_docs = xson::object{};

                        const auto guard = std::lock_guard{m_engine};
                        auto collection = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection);
                        
                        // Check if document exists
                        auto exists = m_engine.read(selector, existing_docs);
                        auto response_headers = ::http::headers{};
                        const auto resource_path = "/"s + collection + "/"s + std::to_string(id);
                        
                        // Check conditional requests (only if document exists)
                        if(exists && !existing_docs.get<xson::object::array>().empty())
                        {
                            // Check If-Match header (ETag-based)
                            auto metadata_position = m_engine.get_metadata_position(selector);
                            if(metadata_position.has_value())
                            {
                                auto current_etag = generate_etag(metadata_position.value());
                                auto match_check = check_if_match(headers, current_etag);
                                if(match_check.has_value() && !match_check.value())
                                {
                                    // Precondition failed - ETag doesn't match
                                    auto error = xson::object{
                                        {"error", "Precondition Failed"s},
                                        {"message", "ETag does not match current resource version"s},
                                        {"collection", collection},
                                        {"id", id}
                                    };
                                    return std::make_tuple("412 Precondition Failed"s, xson::json::stringify(error), std::optional<::http::headers>{});
                                }
                            }
                            
                            // Check If-Unmodified-Since conditional request
                            auto metadata_timestamp = m_engine.get_metadata_timestamp(selector);
                            if(metadata_timestamp.has_value())
                            {
                                auto unmodified_check = check_if_unmodified_since(headers, metadata_timestamp.value());
                                if(unmodified_check.has_value() && !unmodified_check.value())
                                {
                                    // Precondition failed - document was modified since client's date
                                    auto error = xson::object{
                                        {"error", "Precondition Failed"s},
                                        {"message", "Document has been modified since the specified date"s},
                                        {"collection", collection},
                                        {"id", id}
                                    };
                                    return std::make_tuple("412 Precondition Failed"s, xson::json::stringify(error), std::optional<::http::headers>{});
                                }
                            }
                        }
                        
                        // Add OData metadata if requested
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                            document = yar::http::odata::add_metadata(document, metadata_level, collection, id);
                        
                        if(exists && !existing_docs.get<xson::object::array>().empty())
                        {
                            // Document exists - replace it
                            m_engine.replace(selector, document);
                            
                            // Get new ETag after update
                            auto new_metadata_position = m_engine.get_metadata_position(selector);
                            if(new_metadata_position.has_value())
                            {
                                auto new_etag = generate_etag(new_metadata_position.value());
                                response_headers.set("etag"s, new_etag);
                            }
                            
                            // Add Content-Location header for updated resource
                            response_headers.set("content-location"s, resource_path);
                            
                            // Return 200 OK for update
                            return std::make_tuple("200 OK"s, xson::json::stringify(document), std::make_optional(response_headers));
                        }
                        else
                        {
                            // Document doesn't exist - create it
                            m_engine.create(document);
                            
                            // Get ETag after creation
                            auto new_metadata_position = m_engine.get_metadata_position(selector);
                            if(new_metadata_position.has_value())
                            {
                                auto new_etag = generate_etag(new_metadata_position.value());
                                response_headers.set("etag"s, new_etag);
                            }
                            
                            // Add Location header for newly created resource
                            response_headers.set("location"s, resource_path);
                            
                            return std::make_tuple("201 Created"s, xson::json::stringify(document), std::make_optional(response_headers));
                        }
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }
                });

        // Update aka modify _id
        m_server.patch("/[a-z][a-z0-9]*/[0-9]+"s).response_with_headers(
            "application/json"sv,
            [this](std::string_view request, std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "PATCH /[a-z]+: "<< request << " <- " << body << flush;

                    // Check Accept header
                    if(!accepts_json(headers))
                    {
                        auto error = xson::object{
                            {"error", "Not Acceptable"s},
                            {"message", "Only application/json is supported"s}
                        };
                        return std::make_tuple("406 Not Acceptable"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto updates = xson::json::parse(body);
                        auto documents = xson::object{};
                        auto id = stoll(uri.path[2]);
                        auto selector = xson::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        auto collection = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection);
                        
                        // Check conditional requests (only if document exists)
                        auto existing_docs = xson::object{};
                        auto exists = m_engine.read(selector, existing_docs);
                        if(exists && !existing_docs.get<xson::object::array>().empty())
                        {
                            // Check If-Match header (ETag-based)
                            auto metadata_position = m_engine.get_metadata_position(selector);
                            if(metadata_position.has_value())
                            {
                                auto current_etag = generate_etag(metadata_position.value());
                                auto match_check = check_if_match(headers, current_etag);
                                if(match_check.has_value() && !match_check.value())
                                {
                                    // Precondition failed - ETag doesn't match
                                    auto error = xson::object{
                                        {"error", "Precondition Failed"s},
                                        {"message", "ETag does not match current resource version"s},
                                        {"collection", collection},
                                        {"id", id}
                                    };
                                    return std::make_tuple("412 Precondition Failed"s, xson::json::stringify(error), std::optional<::http::headers>{});
                                }
                            }
                            
                            // Check If-Unmodified-Since conditional request
                            auto metadata_timestamp = m_engine.get_metadata_timestamp(selector);
                            if(metadata_timestamp.has_value())
                            {
                                auto unmodified_check = check_if_unmodified_since(headers, metadata_timestamp.value());
                                if(unmodified_check.has_value() && !unmodified_check.value())
                                {
                                    // Precondition failed - document was modified since client's date
                                    auto error = xson::object{
                                        {"error", "Precondition Failed"s},
                                        {"message", "Document has been modified since the specified date"s},
                                        {"collection", collection},
                                        {"id", id}
                                    };
                                    return std::make_tuple("412 Precondition Failed"s, xson::json::stringify(error), std::optional<::http::headers>{});
                                }
                            }
                        }
                        
                        m_engine.upsert(selector,updates,documents);
                        
                        // Add OData metadata if requested
                        auto metadata_level = yar::http::odata::parse_metadata_level(headers);
                        if(metadata_level != yar::http::odata::metadata_level::none)
                        {
                            if(documents.is_array() && !documents.get<xson::object::array>().empty())
                            {
                                // PATCH returns array with updated document(s)
                                auto& items = documents.get<xson::object::array>();
                                for(auto& item : items)
                                {
                                    item = yar::http::odata::add_metadata(item, metadata_level, collection, id);
                                }
                            }
                            else if(!documents.is_array())
                            {
                                // Single object
                                documents = yar::http::odata::add_metadata(documents, metadata_level, collection, id);
                            }
                        }
                        
                        // Add Content-Location header for updated resource
                        auto response_headers = ::http::headers{};
                        response_headers.set("content-location"s, "/"s + collection + "/"s + std::to_string(id));
                        
                        // Get new ETag after update
                        auto new_metadata_position = m_engine.get_metadata_position(selector);
                        if(new_metadata_position.has_value())
                        {
                            auto new_etag = generate_etag(new_metadata_position.value());
                            response_headers.set("etag"s, new_etag);
                        }
                        
                        return std::make_tuple("200 OK"s, xson::json::stringify(documents), std::make_optional(response_headers));
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error), std::optional<::http::headers>{});
                    }
                });

        // Delete _id
        m_server.destroy("/[a-z][a-z0-9]*/[0-9]+"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, const ::http::headers& headers)
                {
                    slog << debug << "DELETE /[a-z]+/[0-9]+: " << request << flush;

                    // Check Accept header (for error responses)
                    if(!accepts_json(headers))
                        return not_acceptable_response();

                    try
                    {
                        auto uri = ::http::uri{request};
                        auto id = stoll(uri.path[2]);
                        auto documents = xson::object{};
                        auto selector = xson::object{"_id", id};

                        const auto guard = std::lock_guard{m_engine};
                        auto collection = validate_collection_name(uri.path[1]);
                        m_engine.collection(collection);
                        auto deleted = m_engine.destroy(selector,documents);

                        if(!deleted)
                        {
                            auto error = xson::object{
                                {"error", "Not Found"s},
                                {"message", "Document not found"s},
                                {"collection", collection},
                                {"id", id}
                            };
                            return std::make_tuple("404 Not Found"s, xson::json::stringify(error));
                        }

                        // Return 204 No Content for successful deletion
                        return std::make_tuple("204 No Content"s, ""s);
                    }
                    catch(const std::exception& e)
                    {
                        auto error = xson::object{
                            {"error", "Bad Request"s},
                            {"message", std::string{e.what()}}
                        };
                        return std::make_tuple("400 Bad Request"s, xson::json::stringify(error));
                    }
                });

        // Delete first
        m_server.destroy("/[a-z]+\\?\\$top"s).response(
            "application/json"sv,
            [this](std::string_view request, [[maybe_unused]] std::string_view body, [[maybe_unused]] const ::http::headers& headers)
                {
                    slog << debug << "DELETE /[a-z]+?\\$top: " << request << flush;

                    auto uri = ::http::uri{request};
                    auto documents = xson::object{};
                    auto selector = xson::object{"$top",1ll};

                    const auto guard = std::lock_guard{m_engine};
                    m_engine.collection(uri.path[1]);
                    m_engine.destroy(selector,documents);
                    return std::make_tuple("200 OK"s, xson::json::stringify(documents));
                });
    }

    std::string m_file;
    std::string m_port_or_service;
    ext::lockable<yar::db::engine> m_engine;
    ::http::server m_server;
    std::thread m_listen_thread;
};

// Backward compatibility wrapper function (blocks forever)
export void restful_web_server(std::string_view file, const std::string_view port_or_service)
{
    auto server = rest_api_server{file, port_or_service};
    server.listen(); // Blocks forever
}

} // namespace yar::http
